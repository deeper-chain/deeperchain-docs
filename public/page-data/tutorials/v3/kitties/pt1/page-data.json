{
    "componentChunkName": "component---src-templates-tut-template-tsx",
    "path": "/tutorials/v3/kitties/pt1/",
    "result": {"data":{"mdx":{"frontmatter":{"slug":"/tutorials/v3/kitties/pt1","title":"Build the Substrate Kitties Chain","hideNav":null,"difficulty":2,"duration":"2 Hours","relevantSkills":["FRAME","Rust"],"section":"tutorials","category":"FRAME"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Build the Substrate Kitties Chain\",\n  \"slug\": \"/tutorials/v3/kitties/pt1\",\n  \"version\": 3,\n  \"section\": \"tutorials\",\n  \"category\": \"FRAME\",\n  \"keywords\": \"nft, kitties\",\n  \"difficulty\": 2,\n  \"duration\": \"2 Hours\",\n  \"relevantSkills\": [\"FRAME\", \"Rust\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Message = makeShortcode(\"Message\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/img/tutorials/kitties-workshop/kitties-tutorial.png\",\n    \"alt\": \"image\"\n  })), mdx(\"p\", null, \"Welcome to the Substrate Kitties workshop. This workshop is split into two separate parts, designed\\nto teach you everything you need to know about building a blockchain that handles the creation and\\nownership management of Substrate Kitties. \"), mdx(\"p\", null, \"Part I will cover how to build the Kitties pallet,\\nincluding the functionality to interact with the Kitties we create, such as transferring, buying\\nand setting prices. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/tutorials/v3/kitties/pt2\"\n  }, \"Part II\"), \" will cover developing the Front-end UI to\\ninteract with the blockchain we build in Part I.\"), mdx(\"h2\", {\n    \"id\": \"tutorial-objectives\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#tutorial-objectives\",\n    \"aria-label\": \"tutorial objectives permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Tutorial objectives\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Learn basic patterns for building and running a Substrate node.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Write and integrate a custom FRAME pallet to your runtime.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Learn how to create and update storage items.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Write pallet extrinsics and helper functions.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use the PolkadotJS API to connect a Substrate node to a custom a front-end.\")), mdx(\"p\", null, \"This tutorial assumes that you have already installed the prerequisites for building with Substrate\\non your machine. If you haven't already, head over to our\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/getting-started/installation\"\n  }, \"installation guide\"), \".\"), mdx(\"h3\", {\n    \"id\": \"what-were-building\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#what-were-building\",\n    \"aria-label\": \"what were building permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"What we're building\"), mdx(\"p\", null, \"In Part I of this tutorial, we'll intentionally keep things simple so that you can decide on how\\nyou'd like to improve your Substrate Kitties chain later on. For the purposes of what we're building,\\nKitties really can only do the following things:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Be created either by some original source or by being bred using existing Kitties.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Be sold at a price set by their owner.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Be transferred from one owner to another.\"))), mdx(\"h3\", {\n    \"id\": \"what-we-wont-cover\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#what-we-wont-cover\",\n    \"aria-label\": \"what we wont cover permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"What we won't cover\"), mdx(\"p\", null, \"The following items fall outside the scope of this tutorial:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Writing tests for our pallet.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using correct weight values \")), mdx(\"p\", null, \"You can refer to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/how-to-guides/v3\"\n  }, \"how-to guides\"), \" on how to integrate these once you've completed this\\nworkshop.\"), mdx(Message, {\n    type: \"green\",\n    title: \"Tip\",\n    text: \"\\nFollow each step at your own pace &mdash; the goal is for you to learn and the best way to do\\nthat is to try it yourself!\\n\\nBefore moving on from one section to the next, make sure your pallet builds without any error.\\nYou'll be writing most of the code yourself! Use the template files\\n[here](https://github.com/substrate-developer-hub/substrate-docs/tree/main/static/assets/tutorials/kitties-tutorial)\\nto help you complete each part.\\n\\nIf you are stuck in following the tutorial, refer to the complete source code at:\\n- On Substrate end, [Substrate Node Template repository `tutorials/kitties` branch](https://github.com/substrate-developer-hub/substrate-node-template/tree/tutorials/kitties).\\nMost of the code changes are under `/pallets/kitties/src/lib.rs`.\\n- On front end, [Substrate Front-end Template repository `tutorials/kitties` branch](https://github.com/substrate-developer-hub/substrate-front-end-template/tree/tutorials/kitties).\\nMost of the code changes are within these three files: `/src/[Kitties.js, KittyCards.js, KittyAvatar.js]`.\\n\",\n    mdxType: \"Message\"\n  }), mdx(\"h2\", {\n    \"id\": \"basic-set-up\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#basic-set-up\",\n    \"aria-label\": \"basic set up permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Basic set-up\"), mdx(\"p\", null, \"Before we can start making Kitties, we first need to do a little groundwork. This part covers the\\nbasic patterns involved with using the Substrate Node Template to set up a custom pallet and\\ninclude a simple storage item.\"), mdx(\"h3\", {\n    \"id\": \"set-up-your-template-node\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#set-up-your-template-node\",\n    \"aria-label\": \"set up your template node permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Set-up your template node\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/substrate-developer-hub/substrate-node-template\"\n  }, \"Substrate Node Template\"), \" provides us with an \\\"out-of-the-box\\\"\\nblockchain node. Our biggest advantage in using it are that both networking and consensus layers\\nare already built and all we need to focus on is building out the logic of our \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/concepts/runtime\"\n  }, \"runtime\"), \" and\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/frame#pallets\"\n  }, \"pallets\"), \". Before we get there, we need to set-up our project in terms of naming\\nand dependencies.\"), mdx(\"p\", null, \"We'll use a CLI tool called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Keats/kickstart\"\n  }, \"kickstart\"), \" to easily rename our node template. Install it by\\nrunning \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo install kickstart\"), \".\"), mdx(\"p\", null, \"Once \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kickstart\"), \" is installed, in the root directory of your local workspace run the following command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"kickstart https://github.com/sacha-l/kickstart-substrate\\n\")), mdx(\"p\", null, \"This command will clone a copy of the most recent Node Template and ask how you would like to call\\nyour node and pallet. Type in:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"kitties\"), \" - as the name of our node. The node will be named as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"node-kitties\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"kitties\"), \" - as the name of your pallet. The pallet will be named as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pallet-kitties\"), \".\")), mdx(\"p\", null, \"This will create a directory called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kitties\"), \" with a copy of the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/substrate-developer-hub/substrate-node-template\"\n  }, \"Substrate Node Template\"), \"\\ncontaining the name changes that correspond our template node, runtime, and pallet.\"), mdx(\"p\", null, \"Open the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kitties\"), \" directory in your favorite code editor and rename it as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kitties-tutorial\"), \".\\nRenaming this directory will be helpful once you start creating other projects with the node\\ntemplate \", \"\\u2014\", \" it'll help keep things organized!\"), mdx(\"p\", null, \"Notice the directories that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kickstart\"), \" command modified:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"`\", \"/node/\", \"`\"), \" - This contains all the logic that allows your node to interact with your runtime\\nand RPC clients.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"`\", \"/pallets/\", \"`\"), \" - Here's where all your custom pallets live.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"`\", \"/runtime/\", \"`\"), \" - This is where all pallets (both custom \\\"internal\\\" and \\\"external\\\" ones) are\\naggregated and implemented for the chain's runtime.\")), mdx(\"p\", null, \"You'll also notice that the instance of our modified template pallet name remains\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TemplateModule\"), \". Change it to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SubstrateKitties\"), \" (in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runtime/src/lib.rs\"), \") and add\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Config<T>\"), \" to the pallet declaration:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"construct_runtime!(\\n    pub enum Runtime where\\n    Block = Block,\\n    NodeBlock = opaque::Block,\\n    UncheckedExtrinsic = UncheckedExtrinsic\\n    {\\n        // --snip\\n        SubstrateKitties: pallet_kitties::{Pallet, Call, Config<T>, Storage, Event<T>}, // <-- add this line\\n    }\\n);\\n\")), mdx(\"h3\", {\n    \"id\": \"write-the-pallet_kitties-scaffold\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#write-the-pallet_kitties-scaffold\",\n    \"aria-label\": \"write the pallet_kitties scaffold permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Write the \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"pallet_kitties\"), \" scaffold\"), mdx(\"p\", null, \"We'll be spending most of this tutorial in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pallets\"), \" directory of our template node. Let's take\\na glance at the folder structure in our workspace:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"kitties-tutorial           <--  The name of our project directory\\n|\\n+-- node\\n|\\n+-- pallets\\n|   |\\n|   +-- kitties\\n|       |\\n|       +-- Cargo.toml\\n|       |\\n|       +-- src\\n|           |\\n|           +-- benchmarking.rs     <-- Remove file\\n|           |\\n|           +-- lib.rs              <-- Remove contents\\n|           |\\n|           +-- mock.rs             <-- Remove file\\n|           |\\n|           +-- tests.rs            <-- Remove file\\n|\\n+-- Cargo.toml\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"You can go ahead and remove \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"benchmarking.rs\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mock.rs\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tests.rs\"), \". \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"We won't be learning about\\nusing these in this tutorial. Have a look at \", mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"/how-to-guides/v3/testing/transfer-function\"\n  }, \"this how-to guide\"), \" if\\nyou're curious to learn how testing works.\"))), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/frame#pallets\"\n  }, \"Pallets\"), \" in Substrate are used to define runtime logic. In our case, we'll be creating\\na single pallet that manages all of the logic of our Substrate Kitties application.\"), mdx(\"p\", null, \"Let's lay out the basic structure of our pallet by outlining the parts inside\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pallets/mykitties/src/lib.rs\"), \".\"), mdx(\"p\", null, \"Notice that our pallet's directory \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pallets/kitties/\"), \" is not the same as our pallet's name. The name\\nof our pallet as Cargo understands it is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pallet-kitties\"), \".\"), mdx(\"p\", null, \"Every FRAME pallet has:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A set of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"frame_support\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"frame_system\"), \" dependencies.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Required \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/v3/runtime/macros#frame-macros-and-attributes\"\n  }, \"attribute macros\"), \" (i.e. configuration traits, storage items and function\\ncalls).\")), mdx(Message, {\n    type: \"yellow\",\n    title: \"Information\",\n    text: \"\\nWe'll be updating additional dependencies as we progress through the next parts of this tutorial.\\n  \",\n    mdxType: \"Message\"\n  }), mdx(\"p\", null, \"Here's the most bare-bones version of the Kitties pallet we will be building in this tutorial. It\\ncontains the starting point for adding code for the next sections of this tutorial. Just like the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/substrate-developer-hub/substrate-docs/tree/main/static/assets/tutorials/kitties-tutorial\"\n  }, \"helper files\"), \"\\nfor this tutorial, it contains comments marked with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TODO\"), \" to indicate code we will\\nbe writing later, and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ACTION\"), \" to indicate code that will be written in the current section. \"), mdx(\"p\", null, \"Paste the following code in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/pallets/kitties/src/lib.rs\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#![cfg_attr(not(feature = \\\"std\\\"), no_std)]\\n\\npub use pallet::*;\\n\\n#[frame_support::pallet]\\npub mod pallet {\\n    use frame_support::{sp_runtime::traits::{Hash, Zero},\\n                        dispatch::{DispatchResultWithPostInfo, DispatchResult},\\n                        traits::{Currency, ExistenceRequirement, Randomness},\\n                        pallet_prelude::*};\\n    use frame_system::pallet_prelude::*;\\n    use sp_io::hashing::blake2_128;\\n\\n    // TODO Part II: Struct for holding Kitty information.\\n\\n    // TODO Part II: Enum and implementation to handle Gender type in Kitty struct.\\n\\n    #[pallet::pallet]\\n    #[pallet::generate_store(trait Store)]\\n    pub struct Pallet<T>(_);\\n\\n    /// Configure the pallet by specifying the parameters and types it depends on.\\n    #[pallet::config]\\n    pub trait Config: frame_system::Config {\\n        /// Because this pallet emits events, it depends on the runtime's definition of an event.\\n        type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;\\n\\n        /// The Currency handler for the Kitties pallet.\\n        type Currency: Currency<Self::AccountId>;\\n\\n        // TODO Part II: Specify the custom types for our runtime.\\n\\n    }\\n\\n    // Errors.\\n    #[pallet::error]\\n    pub enum Error<T> {\\n        // TODO Part III\\n    }\\n\\n    #[pallet::event]\\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\\n    pub enum Event<T: Config> {\\n        // TODO Part III\\n    }\\n\\n    // ACTION: Storage item to keep a count of all existing Kitties.\\n\\n    // TODO Part II: Remaining storage items.\\n\\n    // TODO Part III: Our pallet's genesis configuration.\\n\\n    #[pallet::call]\\n    impl<T: Config> Pallet<T> {\\n\\n        // TODO Part III: create_kitty\\n\\n        // TODO Part III: set_price\\n\\n        // TODO Part III: transfer\\n\\n        // TODO Part III: buy_kitty\\n\\n        // TODO Part III: breed_kitty\\n    }\\n\\n    // TODO Parts II: helper function for Kitty struct\\n\\n    impl<T: Config> Pallet<T> {\\n        // TODO Part III: helper functions for dispatchable functions\\n\\n        // TODO: increment_nonce, random_hash, mint, transfer_from\\n\\n    }\\n}\\n\")), mdx(\"p\", null, \"Now try running the following command to build your pallet. We won't build the entire chain just yet\\nbecause we haven't yet implemented the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Currency\"), \" type in our runtime. At least we can check that there\\nare no errors in our pallet so far:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"cargo build -p pallet-kitties\\n\")), mdx(\"br\", null), mdx(Message, {\n    type: \"red\",\n    title: \"Warning\",\n    text: \"\\nCheck that you're using the correct `monthly-*` tag and version otherwise you will get a\\ndependency error. Here, we're using the `monthly-2021-10` tag of Substrate.\\n  \",\n    mdxType: \"Message\"\n  }), mdx(\"p\", null, \"You'll notice the Rust compiler giving you warnings about unused imports. That's fine! Just ignore\\nthem \", \"\\u2014\", \" we're going to be using those imports in the later parts of the tutorial.\"), mdx(\"h3\", {\n    \"id\": \"add-storage-items\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#add-storage-items\",\n    \"aria-label\": \"add storage items permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Add storage items\"), mdx(\"p\", null, \"Let's start add the most simple logic we can to our runtime: a function that stores a\\nvariable in runtime.\"), mdx(\"p\", null, \"To do this we'll use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.StorageValue.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"StorageValue\")), \" from Substrate's\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/index.html\"\n  }, \"storage API\"), \" which is a trait that depends on the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/macros#palletstorage\"\n  }, \"storage macro\"), \".\"), mdx(\"p\", null, \"All that means for our purposes is that for any storage item we want to declare, we must include the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[pallet::storage]\"), \"  macro beforehand. Learn more about declaring storage items \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/storage#declaring-storage-items\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pallets/kitties/src/lib.rs\"), \", replace the ACTION line with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::storage]\\n#[pallet::getter(fn kitty_cnt)]\\n/// Keeps track of the number of Kitties in existence.\\npub(super) type KittyCnt<T: Config> = StorageValue<_, u64, ValueQuery>;\\n\")), mdx(\"p\", null, \"This creates a storage item for our pallet to keep track of the total count of Kitties in existence.\"), mdx(\"h3\", {\n    \"id\": \"add-currency-implementation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#add-currency-implementation\",\n    \"aria-label\": \"add currency implementation permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Add Currency implementation\"), mdx(\"p\", null, \"Before we proceed with building our node, we need to add the Currency type to our pallet's runtime\\nimplementation. In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runtime/src/lib.rs\"), \", add the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"impl pallet_kitties::Config for Runtime {\\n    type Event = Event;\\n    type Currency = Balances; // <-- Add this line\\n}\\n\")), mdx(\"p\", null, \"Now build your node and make sure you don't have any errors. This will take a little while at first.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"cargo build --release\\n\")), mdx(\"br\", null), mdx(Message, {\n    type: \"green\",\n    title: \"Congratulations!\",\n    text: \"\\nYou've completed the first part of this series. At this stage, you've learnt the\\nvarious patterns for:\\n- Customizing the Substrate Node Template and including a custom pallet.\\n- Building a Substrate chain and checking that a target pallet compiles.\\n- Declaring a single value `u64` storage item.\\n  \",\n    mdxType: \"Message\"\n  }), mdx(\"h2\", {\n    \"id\": \"uniqueness-custom-types-and-storage-maps\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#uniqueness-custom-types-and-storage-maps\",\n    \"aria-label\": \"uniqueness custom types and storage maps permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Uniqueness, custom types and storage maps\"), mdx(\"p\", null, \"This section dives into some pillar concepts for developing pallets with FRAME\\n(\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Framework for Runtime Aggregation of Modularized Entities\"), \"), incuding writing \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/how-to-guides/v3/pallet-design/storage-value\"\n  }, \"a storage\\nstruct\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/how-to-guides/v3/pallet-design/randomness\"\n  }, \"implementing the randomness trait\\n\"), \". On top of learning how to use existing types and traits,\\nyou'll learn how create your own types like providing your pallet with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gender\"), \" type. At the\\nend of this part, you will have implemented the remaining two storage items according to the logic\\noutlined for the Substrate Kitty application \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#what-were-building\"\n  }, \"in the overview of this tutorial\"), \".\"), mdx(\"p\", null, \"We added additional comments to the code from Part I in a dedicated helper file\\nto better assist you with the action items of this section. To follow each step with\\nease, you can just replace your code with the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/substrate-developer-hub/substrate-docs/tree/main/static/assets/tutorials/kitties-tutorial/02-create-kitties.rs\"\n  }, \"helper code\"), \"\\nprovided below:\"), mdx(Message, {\n    type: \"green\",\n    title: \"Tip\",\n    text: \"\\nIf you're feeling confident, you can use the code from the previous part and use the comments marked\\nas \\\"TODO\\\" to follow each step instead of pasting in the helper file for this part.\\n  \",\n    mdxType: \"Message\"\n  }), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#![cfg_attr(not(feature = \\\"std\\\"), no_std)]\\n\\npub use pallet::*;\\n\\n#[frame_support::pallet]\\npub mod pallet {\\n    use frame_support::pallet_prelude::*;\\n    use frame_system::pallet_prelude::*;\\n    use frame_support::{\\n        sp_runtime::traits::Hash,\\n        traits::{ Randomness, Currency, tokens::ExistenceRequirement },\\n        transactional\\n    };\\n    use sp_io::hashing::blake2_128;\\n\\n    #[cfg(feature = \\\"std\\\")]\\n    use serde::{Deserialize, Serialize};\\n\\n    // ACTION #1: Write a Struct to hold Kitty information.\\n\\n    // ACTION #2: Enum declaration for Gender.\\n\\n    // ACTION #3: Implementation to handle Gender type in Kitty struct.\\n\\n    #[pallet::pallet]\\n    #[pallet::generate_store(pub(super) trait Store)]\\n    pub struct Pallet<T>(_);\\n\\n    /// Configure the pallet by specifying the parameters and types it depends on.\\n    #[pallet::config]\\n    pub trait Config: frame_system::Config {\\n        /// Because this pallet emits events, it depends on the runtime's definition of an event.\\n        type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;\\n\\n        /// The Currency handler for the Kitties pallet.\\n        type Currency: Currency<Self::AccountId>;\\n\\n        // ACTION #5: Specify the type for Randomness we want to specify for runtime.\\n\\n        // ACTION #9: Add MaxKittyOwned constant\\n    }\\n\\n    // Errors.\\n    #[pallet::error]\\n    pub enum Error<T> {\\n        // TODO Part III\\n    }\\n\\n    // Events.\\n    #[pallet::event]\\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\\n    pub enum Event<T: Config> {\\n        // TODO Part III\\n    }\\n\\n    #[pallet::storage]\\n    #[pallet::getter(fn all_kitties_count)]\\n    pub(super) type KittyCnt<T: Config> = StorageValue<_, u64, ValueQuery>;\\n\\n    // ACTION #7: Remaining storage items.\\n\\n    // TODO Part IV: Our pallet's genesis configuration.\\n\\n    #[pallet::call]\\n    impl<T: Config> Pallet<T> {\\n\\n        // TODO Part III: create_kitty\\n\\n        // TODO Part IV: set_price\\n\\n        // TODO Part IV: transfer\\n\\n        // TODO Part IV: buy_kitty\\n\\n        // TODO Part IV: breed_kitty\\n    }\\n\\n    //** Our helper functions.**//\\n\\n    impl<T: Config> Pallet<T> {\\n\\n        // ACTION #4: helper function for Kitty struct\\n\\n        // TODO Part III: helper functions for dispatchable functions\\n\\n        // ACTION #6: funtion to randomly generate DNA\\n\\n        // TODO Part III: mint\\n\\n        // TODO Part IV: transfer_kitty_to\\n    }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"scaffold-kitty-struct\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#scaffold-kitty-struct\",\n    \"aria-label\": \"scaffold kitty struct permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Scaffold Kitty struct\"), mdx(\"p\", null, \"A Struct in Rust is a useful construct to help store data that have things in common. For our\\npurposes, our Kitty will carry multiple properties which we can store in a single struct instead\\nof using separate storage items. This comes in handy when trying to optimize for storage reads and\\nwrites so our runtime can perform less read/writes to update multiple values. Read more about\\nstorage best practices \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/storage#best-practices\"\n  }, \"here\"), \".\"), mdx(\"h4\", null, \"What information to include\"), mdx(\"p\", null, \"Let's first go over what information a single Kitty will carry:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"dna\")), \": the hash used to identify the DNA of a Kitty, which corresponds to its unique features.\\nDNA is also used to breed new Kitties and to keep track of different Kitty generations.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"price\")), \": this is a balance that corresponds to the amount needed to buy a Kitty and\\nset by its owner.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"gender\")), \": an enum that can be either \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Male\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Female\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"owner\")), \": an account ID designating a single owner.\")), mdx(\"h4\", null, \"Sketching out the types held by our struct\"), mdx(\"p\", null, \"Looking at the items of our struct from above, we can deduce the following types:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[u8; 16]\")), \" for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"dna\"), \" - to use 16 bytes to represent a Kitty's DNA.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"BalanceOf\")), \" for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"price\"), \" - this is a custom type using FRAME's \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/traits/tokens/currency/trait.Currency.html#associatedtype.Balance\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Currency\"), \" trait\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"Gender\")), \" for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gender\"), \" - we are going to create this!\")), mdx(\"p\", null, \"First, we will need to add in our custom types for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BalanceOf\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AccountOf\"), \" before we declare our\\nstruct. Replace ACTION #1 with the following snippet:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"type AccountOf<T> = <T as frame_system::Config>::AccountId;\\ntype BalanceOf<T> =\\n    <<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;\\n\\n// Struct for holding Kitty information.\\n#[derive(Clone, Encode, Decode, PartialEq, RuntimeDebug, TypeInfo)]\\n#[scale_info(skip_type_params(T))]\\npub struct Kitty<T: Config> {\\n    pub dna: [u8; 16],\\n    pub price: Option<BalanceOf<T>>,\\n    pub gender: Gender,\\n    pub owner: AccountOf<T>,\\n}\\n\")), mdx(\"br\", null), mdx(Message, {\n    type: \"gray\",\n    title: \"Note\",\n    text: \"\\nWe define `<BalanceOf<T>>` and `AccountOf<T>` types, and use them in the `Kitty`. If you\\nwonder what the first line means in Rust, it is to define a type alias `AccountOf<T>` which is\\njust a shorthand pointing to the associated type `AccountId` of trait `frame_system::Config`\\nthat generic type `T` is required to be bound of.\\n\\n\\nMore about this type of syntax is covered in [the Rust book](https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types).\\n\",\n    mdxType: \"Message\"\n  }), mdx(\"p\", null, \"Notice how we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"derive\"), \" macro to include \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sp_std/prelude/index.html#traits\"\n  }, \"various helper traits\"), \" for\\nusing our struct. We'll need to add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeInfo\"), \" in order to give our struct access to this trait. Add the\\nfollowing line at the top of your pallet:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use scale_info::TypeInfo;\\n\")), mdx(\"p\", null, \"For type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gender\"), \", we will need to build out our own custom enum and helper\\nfunctions. Now is a good time to do that.\"), mdx(\"h3\", {\n    \"id\": \"write-a-custom-type-for-gender\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#write-a-custom-type-for-gender\",\n    \"aria-label\": \"write a custom type for gender permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Write a custom type for \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"Gender\")), mdx(\"p\", null, \"We have just created a struct that requires a custom type called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gender\"), \". This type will handle an\\nenum defining our Kitty's gender. To create it, you'll build out the following parts:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"An enum declaration\"), \", which specifies \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Male\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Female\"), \" values.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Implement a helper function\"), \" for our Kitty struct.\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"h4\", {\n    parentName: \"li\"\n  }, \"Declare the custom enum\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Replace ACTION item #2 with the following enum declaration:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[derive(Clone, Encode, Decode, PartialEq, RuntimeDebug, TypeInfo)]\\n#[scale_info(skip_type_params(T))]\\n#[cfg_attr(feature = \\\"std\\\", derive(Serialize, Deserialize))]\\npub enum Gender {\\n    Male,\\n    Female,\\n}\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Notice the use of the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros\"\n  }, \"derive macro\"), \" which must precede the enum declaration.\\nThis wraps our enum in the data structures it will need to interface with other types in our\\nruntime. In order to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Serialize\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Deserialize\"), \", you will need to add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"serde\"), \" crate in\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pallets/kitties/Cargo.toml\"), \":\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toml\"\n  }, \"[dependencies.serde]\\ndefault-features = false\\nversion = '1.0.119'\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Great, we now know how to create a custom struct. But what about\\nproviding a way for a Kitty struct to be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"assigned\"), \" a gender value? For that we need to learn one\\nmore thing.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"h4\", {\n    parentName: \"li\"\n  }, \"Implement a helper function for our Kitty struct\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Configuring a struct is useful in order to pre-define a value in our struct. For example, when\\nsetting a value in relation to what another function returns. In our case we have a similar\\nsituation where we need to configure our Kitty struct in such a way that sets \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gender\"), \" according to\\na Kitty's DNA.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"We'll only be using this function when we get to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#write-the-create_kitty-dispatchable\"\n  }, \"creating Kitties\"), \".\\nRegardless, let us learn how to write it now and get it out of the way. We'll create a public\\nfunction called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gen_gender\"), \" that returns the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gender\"), \" type and uses a random function to choose\\nbetween \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gender\"), \" enum values.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Replace ACTION #4 with the following code snippet:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn gen_gender() -> Gender {\\n    let random = T::KittyRandomness::random(&b\\\"gender\\\"[..]).0;\\n    match random.as_ref()[0] % 2 {\\n        0 => Gender::Male,\\n        _ => Gender::Female,\\n    }\\n}\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Now whenever \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gen_gender()\"), \" is called inside our pallet, it will return a pseudo random enum value\\nfor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gender\"), \".\"))), mdx(\"h3\", {\n    \"id\": \"implement-on-chain-randomness\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#implement-on-chain-randomness\",\n    \"aria-label\": \"implement on chain randomness permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Implement on-chain randomness\"), mdx(\"p\", null, \"If we want to be able to tell these Kitties apart, we need to start giving them unique properties!\\nIn the previous step, we've made use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KittyRandomness\"), \" which we haven't actually defined yet.\\nLet's get to it.\"), mdx(\"p\", null, \"We'll be using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/traits/trait.Randomness.html\"\n  }, \"Randomness trait\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frame_support\"), \" to do this. It will\\nbe able to generate a random seed which we'll create unique Kitties with as well as breed new\\nones.\"), mdx(\"p\", null, \"In order to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Randomness\"), \" trait for our pallet, we must:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"h4\", {\n    parentName: \"li\"\n  }, \"Define a new type bound by \", mdx(\"inlineCode\", {\n    parentName: \"h4\"\n  }, \"Randomness\"), \" trait in our pallet's configuration trait\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Randomness\"), \" trait from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frame_support\"), \" requires specifying it with a paramater to replace the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Output\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BlockNumber\"), \" generics. Take a look at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/traits/trait.Randomness.html\"\n  }, \"the documentation\"), \" and\\nthe source code implementation to understand how this works. For our purposes, we want the output\\nof functions using this trait to be \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sp_core/hashing/fn.blake2_128.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Blake2 128-bit hash\")), \" which you'll notice should already be\\ndeclared at the top of your working codebase.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Replace the ACTION #5 line with:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"type KittyRandomness: Randomness<Self::Hash, Self::BlockNumber>;\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"h4\", {\n    parentName: \"li\"\n  }, \"Specify the actual type in our runtime\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Given that we have added a new type in the configuration of our pallet, we need to config our\\nruntime to set its concrete type. This could come in handy if ever we want to change the algorithm\\nthat \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KittyRandomness\"), \" is using, without needing to modify where it's used inside our pallet.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"To showcase this point, we're going to set the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KittyRandomness\"), \" type to an instance of\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/pallet_randomness_collective_flip/index.html\"\n  }, \"FRAME's \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"RandomnessCollectiveFlip\")), \". Conveniently, the Node\\nTemplate already has an instance of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RandomnessCollectiveFlip\"), \" pallet. All you need to do\\nis \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"set the \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"KittyRandomness\"), \" type in your runtime, inside \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"runtime/src/lib.rs\")), \":\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"impl pallet_kitties::Config for Runtime {\\n    type Event = Event;\\n    type Currency = Balances;\\n    type KittyRandomness = RandomnessCollectiveFlip; // <-- ACTION: add this line.\\n}\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Programming is about abstraction. Here we have abstracted out the randomness generation\\nimplementation (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RandomnessCollectiveFlip\"), \") from its interface (\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Randomness<Self::Hash, Self::BlockNumber>\"), \" trait). Check out this \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/how-to-guides/v3/pallet-design/randomness\"\n  }, \"how-to guide\"), \"\\non implementing randomness in case you get stuck. \")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"h4\", {\n    parentName: \"li\"\n  }, \"Generating random DNA\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Generating DNA is similar to using randomness to randomly assign a gender type. The difference is\\nthat we'll be making use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blake2_128\"), \" we imported in the previous part. Replace the ACTION #6\\nline with:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn gen_dna() -> [u8; 16] {\\n    let payload = (\\n        T::KittyRandomness::random(&b\\\"dna\\\"[..]).0,\\n        <frame_system::Pallet<T>>::block_number(),\\n    );\\n    payload.using_encoded(blake2_128)\\n}\\n\")))), mdx(\"h3\", {\n    \"id\": \"write-remaining-storage-items\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#write-remaining-storage-items\",\n    \"aria-label\": \"write remaining storage items permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Write remaining storage items\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"h4\", {\n    parentName: \"li\"\n  }, \"Understanding storage item logic\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"To easily track all of our kitties, we're going to standardize our logic to use a unique ID as the\\nglobal key for our storage items. This means that a single unique key will point to our Kitty\\nobject (i.e. the struct we previously declared).\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In order for this to work, we need to make sure that the ID for a new Kitty is always unique. We can\\ndo this with a new storage item \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Kitties\"), \" which will be a mapping from an ID (Hash) to the Kitty\\nobject.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"With this object, we can easily check for collisions by simply checking whether this storage item\\nalready contains a mapping using a particular ID. For example, from inside a dispatchable function\\nwe could check using:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"ensure!(!<Kitties<T>>::exists(new_id), \\\"This new id already exists\\\");\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Our runtime needs to be made aware of:\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Unique assets, like currency or Kitties (this will be held by a storgae map called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Kitties\"), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ownership of those assets, like account IDs (this will be handled a new storage map called\\n\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"KittiesOwned\"), \")\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"h4\", {\n    parentName: \"li\"\n  }, \"Using a \", mdx(\"inlineCode\", {\n    parentName: \"h4\"\n  }, \"StorageMap\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"To create a storage instance for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Kitty\"), \" struct, we'll be using\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/storage/#storage-map\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"StorageMap\")), \"\\n\", \"\\u2014\", \" a hash-map provided to us by FRAME.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Here's what the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Kitties\"), \" storage item looks like:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::storage]\\n#[pallet::getter(fn kitties)]\\npub(super) type Kitties<T: Config> = StorageMap<\\n  _,\\n  Twox64Concat,\\n  T::Hash,\\n  Kitty<T>\\n  >;\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Breaking it down, we declare the storage type and assign a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StorageMap\"), \" that takes:\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/struct.Twox64Concat.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Twox64Concat\")), \" hashing algorithm.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A key of type \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"T::Hash\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A value of type \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Kitty<T>\"), \".\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KittiesOwned\"), \" storage item is similar except that we'll be using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BoundedVec\"), \" to keep track\\nof some maximum number of Kitties we'll configure in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runtime/src/lib.s\"), \".\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::storage]\\n#[pallet::getter(fn kitties_owned)]\\n/// Keeps track of what accounts own what Kitty.\\npub(super) type KittiesOwned<T: Config> = StorageMap<\\n  _, \\n  Twox64Concat, \\n  T::AccountId, \\n  BoundedVec<T::Hash, T::MaxKittyOwned>, \\n  ValueQuery\\n  >;\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Your turn! Copy the two code snippets above to replace line ACTION #7.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Before we can check our pallet compiles, we need to add a new type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MaxKittyOwned\"), \" in the config\\ntrait, which is a pallet constant type (similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KittyRandomness\"), \" in the previous steps).\\nReplace ACTION #9 with:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::constant]\\ntype MaxKittyOwned: Get<u32>;\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Finally, we define \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MaxKittyOwned\"), \" type in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runtime/src/lib.rs\"), \". This is the same pattern as we\\nfollowed for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Currency\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KittyRandomness\"), \" except we'll be adding a fixed \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"u32\"), \" using the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parameter_types!\"), \" macro:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"parameter_types! {              // <- add this macro\\n  // One can own at most 9,999 Kitties\\n  pub const MaxKittyOwned: u32 = 9999;\\n  }\\n\\n/// Configure the pallet-kitties in pallets/kitties.\\nimpl pallet_kitties::Config for Runtime {\\n  type Event = Event;\\n  type Currency = Balances;\\n  type KittyRandomness = RandomnessCollectiveFlip;\\n  type MaxKittyOwned = MaxKittyOwned; // <- add this line\\n}\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Now is a good time to check that your Kitties blockchain compiles!\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"cargo build --release\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Running into difficulties? Check your solution against the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/substrate-developer-hub/substrate-docs/tree/main/static/assets/tutorials/kitties-tutorial/03-dispatchables-and-events.rs\"\n  }, \"completed helper code\"), \"\\nfor this part of the tutorial.\"))), mdx(\"h2\", {\n    \"id\": \"dispatchables-events-and-errors\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#dispatchables-events-and-errors\",\n    \"aria-label\": \"dispatchables events and errors permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Dispatchables, events, and errors\"), mdx(\"p\", null, \"In the previous section of this tutorial, we laid down the foundations geared to manage the\\nownership of our Kitties \", \"\\u2014\", \" even though they don't really exist yet! In this part of the\\ntutorial, we'll be putting these foundations to use by giving our pallet the ability to create a\\nKitty using the storage items we've declared. Breaking things down a little, we're going to write:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"create_kitty\")), \": a dispatchable or publicly callable function allowing an account to mint\\na Kitty.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"mint()\")), \": a helper function that updates our pallet's storage items and performs error\\nchecks, called by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"create_kitty\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"pallet \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"Events\")), \": using FRAME's \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"#[pallet::event]\"), \" attribute.\")), mdx(\"p\", null, \"At the end of this part, we'll check that everything compiles without error and call our\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"create_kitty\"), \" extrinsic using the PolkadotJS Apps UI.\"), mdx(Message, {\n    type: \"yellow\",\n    title: \"Information\",\n    text: \"\\nIf you're feeling confident, you can continue building on your codebase from the previous part.\\nOtherwise, refer to our starting base code at [here](https://github.com/substrate-developer-hub/substrate-docs/tree/main/static/assets/tutorials/kitties-tutorial/03-dispatchables-and-events.rs).\\nIt also uses various \\\"ACTION\\\" items as a way to assist you through each step.\\n  \",\n    mdxType: \"Message\"\n  }), mdx(\"h3\", {\n    \"id\": \"public-and-private-functions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#public-and-private-functions\",\n    \"aria-label\": \"public and private functions permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Public and private functions\"), mdx(\"p\", null, \"Before we dive right in, it's important to understand the pallet design decisions we'll be making\\naround coding up our Kitty pallet's minting and ownership management capabilities.\"), mdx(\"p\", null, \"As developers, we want to make sure the code we write is efficient and elegant. Often times,\\noptimizing for one optimizes for the other. The way we're going to set up our pallet to optimize\\nfor both will be to break-up the \\\"heavy lifting\\\" logics into private helper functions. This improves\\ncode readability and reusability too. As we'll see, we can create private functions which can be\\ncalled by multiple dispatchable functions without compromizing on security. In fact, building this\\nway can be considered an additive security feauture. Check out \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/how-to-guides/v3/basics/helper-functions\"\n  }, \"this how-to guide\"), \"\\nabout writing and using helper functions to learn more.\"), mdx(\"p\", null, \"Before jumping into implementing this approach, let's first paint the big picture of what combining\\ndispatchables and helper functions looks like.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"create_kitty\")), \" is a dispatchable function or extrinsic that:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"checks the origin is signed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"generates a random hash with the signing account\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"creates a new Kitty object using the random hash\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"calls a private \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mint()\"), \" function\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"mint\")), \" is a private helper function that:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"checks that the Kitty doesn't already exist\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"updates storage with the new Kitty ID (for all Kitties and for the owner's account)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"updates the new total Kitty count for storage and the new owner's account\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"deposits an Event to signal that a Kitty has succesfully been created\")), mdx(\"h3\", {\n    \"id\": \"write-the-create_kitty-dispatchable\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#write-the-create_kitty-dispatchable\",\n    \"aria-label\": \"write the create_kitty dispatchable permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Write the \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"create_kitty\"), \" dispatchable\"), mdx(\"p\", null, \"A \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/getting-started/glossary#dispatch\"\n  }, \"dispatchable\"), \" in FRAME always follows the same structure. All pallet\\ndispatchables live under the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[pallet::call]\"), \" macro which requires declaring the dispatchables\\nsection with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \" impl<T: Config> Pallet<T> {}\"), \". Read the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/macros#palletcall\"\n  }, \"documentation\"), \" on these\\nFRAME macros to learn how they work. All we need to know here is that they're a useful feature of\\nFRAME that minimizes the code required to write for pallets to be properly integrated in a\\nSubstrate chain's runtime.\"), mdx(\"h4\", null, \"Weights\"), mdx(\"p\", null, \"As per the requirement for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[pallet::call]\"), \" described in the its documentation, every dispatchable\\nfunction must have an associated weight to it. Weights are an important part of developing with\\nSubstrate as they provide safe-guards around the amount of computation to fit in a block at\\nexecution time.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/concepts/weight\"\n  }, \"Substrate's weighting system\"), \" forces developers to think about the computational\\ncomplexity each \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/concepts/execution#executing-extrinsics\"\n  }, \"extrinsic\"), \" carries before it is called so that a node will account\\nfor it's worst case, avoiding lagging the network with extrinsics that may take longer than the\\nspecified block time. Weights are also intimately linked to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/weights-and-fees\"\n  }, \"fee system\"), \" for a\\nsigned extrinsic.\"), mdx(\"p\", null, \"For this simple application, we're going to default all weights to 100.\"), mdx(\"p\", null, \"Assuming you've now replaced the contents of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pallets/kitties/src/lib.rs\"), \" with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/substrate-developer-hub/substrate-docs/tree/main/static/assets/tutorials/kitties-tutorial/03-dispatchables-and-events.rs\"\n  }, \"the helper file\"), \"\\nfor this section, find ACTION #1 and replace it with the following code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::weight(100)]\\npub fn create_kitty(origin: OriginFor<T>) -> DispatchResult {\\n  let sender = ensure_signed(origin)?; // <- add this line\\n  let kitty_id = Self::mint(&sender, None, None)?; // <- add this line\\n  // Logging to the console\\n  log::info!(\\\"A kitty is born with ID: {:?}.\\\", kitty_id); // <- add this line\\n\\n  // ACTION #4: Deposit `Created` event\\n\\n    Ok(())\\n}\\n\")), mdx(\"p\", null, \"We won't go into \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/debugging/\"\n  }, \"debugging\"), \", but logging to the console is a useful tip to make sure your\\npallet is behaving as expected. In order to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"log::info\"), \", add this to your pallet's\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cargo.toml\"), \" file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toml\"\n  }, \"[dependencies.log]\\ndefault-features = false\\nversion = '0.4.14'\\n\")), mdx(\"br\", null), mdx(Message, {\n    type: \"gray\",\n    title: \"Why \\\"DispatchResult\\\" and not \\\"DispatchResultWithPostInfo\\\"?\",\n    text: \"\\nIn `create_kitty` our return was of type `DispatchResult`. Since `mint()` is a helper for\\n`create_kitty`, we don't need to overwrite `PostDispatchInfo`, we can use a return type of\\n[`DispatchResult`](/rustdocs/latest/frame_support/dispatch/type.DispatchResult.html), its unaugmented \\nversion.\\n  \",\n    mdxType: \"Message\"\n  }), mdx(\"h3\", {\n    \"id\": \"write-the-mint-function\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#write-the-mint-function\",\n    \"aria-label\": \"write the mint function permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Write the \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"mint()\"), \" function\"), mdx(\"p\", null, \"As seen when we wrote \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"create_kitty\"), \" in the previous section, we'll need to create \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mint()\"), \" for\\nwriting our new unique Kitty object to the various storage items declared in Part II of this\\ntutorial.\"), mdx(\"p\", null, \"Let's get right to it. Our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mint()\"), \" function will take the following arguments:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"owner\")), \": of type \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"&T::AccountId\"), \" - this indicates whom the kitty belongs to.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"dna\")), \": of type \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Option<[u8; 16]>\"), \" - this specifies the DNA of the kitty going to be minted.\\nIf \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"None\"), \" is passed in, a random DNA will be generated.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"gender\")), \": of type \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Option<Gender>\"), \" - ditto.\")), mdx(\"p\", null, \"And it will return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Result<T::Hash, Error<T>>\"), \".\"), mdx(\"p\", null, \"Paste in the following code snippet to write the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mint\"), \" function, replacing ACTION #2 in the working\\ncodebase:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"// Helper to mint a Kitty.\\npub fn mint(\\n  owner: &T::AccountId,\\n  dna: Option<[u8; 16]>,\\n  gender: Option<Gender>,\\n) -> Result<T::Hash, Error<T>> {\\n  let kitty = Kitty::<T> {\\n    dna: dna.unwrap_or_else(Self::gen_dna),\\n    price: None,\\n    gender: gender.unwrap_or_else(Self::gen_gender),\\n    owner: owner.clone(),\\n  };\\n\\n  let kitty_id = T::Hashing::hash_of(&kitty);\\n\\n  // Performs this operation first as it may fail\\n  let new_cnt = Self::kitty_cnt().checked_add(1)\\n    .ok_or(<Error<T>>::KittyCntOverflow)?;\\n\\n  // Performs this operation first because as it may fail\\n  <KittiesOwned<T>>::try_mutate(&owner, |kitty_vec| {\\n    kitty_vec.try_push(kitty_id)\\n  }).map_err(|_| <Error<T>>::ExceedMaxKittyOwned)?;\\n\\n  <Kitties<T>>::insert(kitty_id, kitty);\\n  <KittyCnt<T>>::put(new_cnt);\\n  Ok(kitty_id)\\n}\\n\")), mdx(\"p\", null, \"Let's go over what the above code is doing.\"), mdx(\"p\", null, \"The first thing we're doing is creating a new Kitty object. Then, we create a unique \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kitty_id\"), \"\\nusing a hashing funciton based on the current properties of the kitty.\"), mdx(\"p\", null, \"Next, we increment the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KittyCnt\"), \" using the storage getter function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Self::kitty_cnt()\"), \". We also\\nchecking for overflow with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"check_add()\"), \" function.\"), mdx(\"p\", null, \"Once we've done with the check, we proceed with updating our storage items by:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Making use of \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.StorageMap.html#tymethod.try_mutate\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"try_mutate\")), \"\\nto update the kitty's owner vector.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Using the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.StorageMap.html#tymethod.insert\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"insert\")), \" method provided by Substrate's StorageMap API to store the\\nactually Kitty object and associate it with its \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"kitty_id\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Using \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.StorageValue.html#tymethod.put\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"put\")), \"\\nprovided by the StorageValue API to store the latest Kitty count.\")), mdx(Message, {\n    type: \"gray\",\n    title: \"A quick recap of our storage items\",\n    text: \"\\n- **`<Kitties<T>>`**: Stores a Kitty's unique traits and price, by storing the Kitty object and\\n  associating it with its Kitty ID.\\n- **`<KittyOwned<T>>`**: Keeps track of what accounts own what Kitties.\\n- **`<KittyCnt<T>>`**: A count of all Kitties in existence.\\n\",\n    mdxType: \"Message\"\n  }), mdx(\"h3\", {\n    \"id\": \"implement-pallet-events\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#implement-pallet-events\",\n    \"aria-label\": \"implement pallet events permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Implement pallet \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"Events\")), mdx(\"p\", null, \"Our pallet can also emit \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/events-and-errors\"\n  }, \"Events\"), \" at the end of the function. This not only reports the\\nsuccess of a function's execution, but also tells the \\\"off-chain world\\\" that some particular state\\ntransition has happened.\"), mdx(\"p\", null, \"FRAME helps us easily manage and declare our pallet's events using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/attr.pallet.html#event-palletevent-optional\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"#[pallet::event]\")), \"\\nattribute. With FRAME macros, events are just an enum declared like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::event]\\n#[pallet::generate_deposit(pub(super) fn deposit_event)]\\npub enum Event<T: Config>{\\n    /// A function succeeded. [time, day]\\n    Success(T::Time, T::Day),\\n}\\n\")), mdx(\"p\", null, \"As you can see in the above snippet, we use attribute macro:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[pallet::generate_deposit(pub(super) fn deposit_event)]\")), mdx(\"p\", null, \"This allows us to deposit a specifc event using the pattern below:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"Self::deposit_event(Event::Success(var_time, var_day));\\n\")), mdx(\"p\", null, \"In order to use events inside our pallet, we need to add a new associated type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Event\"), \" inside our\\npallet's configuration trait \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Config\"), \". Additionally \", \"\\u2014\", \" just as when adding any type to our\\npallet's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Config\"), \" trait \", \"\\u2014\", \" we also need to define it in our runtime \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/runtime/src/lib.rs\"), \".\"), mdx(\"p\", null, \"This pattern is the same as when we added the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KittyRandomness\"), \" type to our pallet's configuration trait\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#implement-on-chain-randomness\"\n  }, \"earlier in this tutorial\"), \" and has already been included from the\\ninitial scaffolding of our codebase:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"  /// Configure the pallet by specifying the parameters and types it depends on.\\n  #[pallet::config]\\n  pub trait Config: frame_system::Config {\\n      /// Because this pallet emits events, it depends on the runtime's definition of an event.\\n      type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;\\n      //--snip--//\\n  }\\n\")), mdx(\"br\", null), mdx(Message, {\n    type: \"yellow\",\n    title: \"Information\",\n    text: \"\\nNotice that each event deposit is meant to be informative which is why it carries the various types\\nassociated with it.\\n\\nIt's good practice to get in the habit of documenting your event declarations so that your code is\\neasy to read. It is convention to document events as such:\\n\\n`/// Description. [types]`\\nLearn more about events [here](/v3/runtime/events-and-errors).\\n  \",\n    mdxType: \"Message\"\n  }), mdx(\"p\", null, \"Declare your pallet events by replacing the ACTION #3 line with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"  /// A new Kitty was sucessfully created. \\\\[sender, kitty_id\\\\]\\n  Created(T::AccountId, T::Hash),\\n  /// Kitty price was sucessfully set. \\\\[sender, kitty_id, new_price\\\\]\\n  PriceSet(T::AccountId, T::Hash, Option<BalanceOf<T>>),\\n  /// A Kitty was sucessfully transferred. \\\\[from, to, kitty_id\\\\]\\n  Transferred(T::AccountId, T::AccountId, T::Hash),\\n  /// A Kitty was sucessfully bought. \\\\[buyer, seller, kitty_id, bid_price\\\\]\\n  Bought(T::AccountId, T::AccountId, T::Hash, BalanceOf<T>),\\n\")), mdx(\"p\", null, \"We'll be using most of these events in the last section of this tutorial. For now let's use\\nthe relevant event for our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"create_kitty\"), \" dispatchable.\"), mdx(\"p\", null, \"Complete it by replacing ACTION #4 with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"Self::deposit_event(Event::Created(sender, kitty_id));\\n\")), mdx(\"br\", null), mdx(Message, {\n    type: \"gray\",\n    title: \"Note\",\n    text: \"\\nIf you're building your codebase from the previous part (and haven't been using the helper file\\nfor this part) you'll need to add `Ok(())` and properly close the `create_kitty` dispatchable.\\n  \",\n    mdxType: \"Message\"\n  }), mdx(\"h3\", {\n    \"id\": \"error-handling\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#error-handling\",\n    \"aria-label\": \"error handling permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Error handling\"), mdx(\"p\", null, \"FRAME provides us with an error handling system using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/events-and-errors\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"[#pallet::errors]\")), \" which allows\\nus to specify errors for our pallet and use them across our pallet's functions.\"), mdx(\"p\", null, \"Declare all possible errors using the provided FRAME macro under \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[pallet::error]\"), \", replace line\\nACTION #5a with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"/// Handles arithemtic overflow when incrementing the Kitty counter.\\nKittyCntOverflow,\\n/// An account cannot own more Kitties than `MaxKittyCount`.\\nExceedMaxKittyOwned,\\n/// Buyer cannot be the owner.\\nBuyerIsKittyOwner,\\n/// Cannot transfer a kitty to its owner.\\nTransferToSelf,\\n/// Handles checking whether the Kitty exists.\\nKittyNotExist,\\n/// Handles checking that the Kitty is owned by the account transferring, buying or setting a price for it.\\nNotKittyOwner,\\n/// Ensures the Kitty is for sale.\\nKittyNotForSale,\\n/// Ensures that the buying price is greater than the asking price.\\nKittyBidPriceTooLow,\\n/// Ensures that an account has enough funds to purchase a Kitty.\\nNotEnoughBalance,\\n\")), mdx(\"p\", null, \"We'll be using these errors once we write the interactive functions in the next section. Notice\\nthat we've already used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KittyCntOverflow\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ExceedMaxKittyOwned\"), \" in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mint\"), \" function.\"), mdx(\"p\", null, \"Now's a good time to see if your chain can compile. Instead of only checking if your pallet\\ncompiles, run the following command to see if everything can build:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"cargo build --release\\n\")), mdx(\"br\", null), mdx(Message, {\n    type: \"yellow\",\n    title: \"Information\",\n    text: \"\\nIf you ran into errors, scroll to the first error message in your terminal, identify what line\\nis giving an error and check whether you've followed each step correctly. Sometimes a mismatch of\\ncurly brackets will unleash a whole bunch of errors that are difficult to understand &mdash; double\\ncheck your code!\\n  \",\n    mdxType: \"Message\"\n  }), mdx(\"p\", null, \"Did that build fine? Congratulations! That's the core functionality of our Kitties pallet. In the\\nnext step you'll be able to see everything you've built so far in action.\"), mdx(\"h3\", {\n    \"id\": \"testing-with-polkadot-js-apps-ui\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#testing-with-polkadot-js-apps-ui\",\n    \"aria-label\": \"testing with polkadot js apps ui permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Testing with Polkadot-JS Apps UI\"), mdx(\"p\", null, \"Assuming that you successfully built your chain, let's run it and use the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://polkadot.js.org/apps/#/explorer\"\n  }, \"PolkadotJS Apps UI\"), \"\\nto interact with it.\"), mdx(\"p\", null, \"In your chain's project directory, run:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"./target/release/node-kitties --tmp --dev\\n\")), mdx(\"p\", null, \"By doing this, we're specifying to run a temporary chain in developer mode, so as not to need to\\npurge storage each time we want to start a fresh chain.\"), mdx(\"p\", null, \"Assuming that blocks are being finalized (which you should be able to see from the terminal in\\nwhich you ran the above command), head over to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://polkadot.js.org/apps/#/explorer\"\n  }, \"Polkadot.js Apps UI\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Follow these steps:\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Check that you're connected to the Local Node. Click on the top left circular network icon, open\\nthe \\\"Development\\\" section, and choose \\\"Local Node\\\". Your node is default to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"127.0.0.1.:9944\"), \".\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Tell the Apps about your custom types. This requires you to navigate to the \\\"\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Settings\"), \"\\\" ->\\n\\\"\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Developer\"), \"\\\" section, and then paste in the editor the following custom types (in JSON format):\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"Gender\\\": {\\n    \\\"_enum\\\": [ \\\"Male\\\", \\\"Female\\\"]\\n  },\\n  \\\"Kitty\\\": {\\n    \\\"dna\\\": \\\"[u8; 16]\\\",\\n    \\\"price\\\": \\\"Option<Balance>\\\",\\n    \\\"gender\\\": \\\"Gender\\\",\\n    \\\"ownder\\\": \\\"AccountId\\\"\\n  }\\n}\\n\")), mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The reason we need this is because Polkadot-JS Apps isn't designed to read custom types by default.\\nBy adding them, it can properly decode each of our storage items that rely on custom types. Add this\\nin a file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"types.json\"), \" in your projects \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runtime\"), \" folder.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Now go to: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"Developer\\\"\"), \" -> \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"Extrinsics\\\"\"), \" and submit a signed extrinsic using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"substrateKitties\"), \"\\nby calling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createKitty()\"), \" dispatchable. Make 3 different transactions from Alice, Bob and\\nCharlie's accounts.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Check for the associated event \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"Created\\\"\"), \" by going to \\\"\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Network\"), \"\\\" -> \\\"\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Explorer\"), \"\\\". You should\\nbe able to see the events emitted and query their block details.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Check your newly created Kitty's details by going to \\\"\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Developer\"), \"\\\" -> \\\"\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Chain State\"), \"\\\". Select\\nthe \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"substrateKitties\"), \" pallet and query \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Kitties(Hash): Kitty\"), \". \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note:\"), \" You'll notice that this\\nis actually querying all of your pallet's storage items!\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Be sure to uncheck the \\\"include option\\\" box and you should be able to see the details of your newly\\nminted Kitty in the following format:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"kitties.kitties: Option<Kitty>\\n[\\n  [\\n    [\\n      0x15cb95604033af239640125a30c45b671a282f3ef42c6fc48a78eb18464b30a9\\n    ],\\n    {\\n      dna: 0xaf2f2b3f77e110a56933903a38cde1eb,\\n      price: null,\\n      gender: Female,\\n      ownder: 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\\n    }\\n  ]\\n]\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Check that other storage items correctly reflect the creation of additional Kitties.\"))), mdx(Message, {\n    type: \"green\",\n    title: \"Congratulations!\",\n    text: \"\\nYou're pretty much able to take it from here at this point! We've learnt how to implement the key\\nparts of what powers a FRAME pallet and how to put them to use. In the next section we'll be building\\non our knowledge by adding more capabilities to our pallet.\\n\\nTo recap, in this part of the tutorial you've learnt how to:\\n\\n- Distinguish between implementing a dispatchable function and a private helper function.\\n- Use `#[pallet::call]`, `#[pallet::event]` and `#[pallet::error]`.\\n- Implement basic error checking with FRAME.\\n- Update values in storage with safety checks.\\n- Implement FRAME events and use them in a function.\\n- Query storage items and chain state using the PolkadotJS Apps UI.\\n  \",\n    mdxType: \"Message\"\n  }), mdx(\"h2\", {\n    \"id\": \"interacting-with-your-kitties\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#interacting-with-your-kitties\",\n    \"aria-label\": \"interacting with your kitties permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Interacting with your Kitties\"), mdx(\"p\", null, \"Up until this point in the tutorial, we've built a chain capable of only creating and tracking the\\nownership of Kitties. Now that that's done, we want to make our runtime more like a game by\\nintroducing other functions like buying and selling Kitties. In order to achieve this, we'll\\nfirst need to enable users to mark and update the price of their Kitties. Then we can add\\nfunctionality to enable users to transfer, buy, and breed Kitties.\"), mdx(\"h3\", {\n    \"id\": \"set-a-price-for-each-kitty\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#set-a-price-for-each-kitty\",\n    \"aria-label\": \"set a price for each kitty permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Set a price for each Kitty\"), mdx(\"p\", null, \"In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/substrate-developer-hub/substrate-docs/tree/main/static/assets/tutorials/kitties-tutorial/04-interacting-functions.rs\"\n  }, \"the helper file for this part of the tutorial\"), \",\\nyou'll notice that the structure of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set_price\"), \" is already laid out.\"), mdx(\"p\", null, \"Your job is to replace ACTION lines #1a, #1b, #2 and #3 with what you'll learn in sections A-D\\nbelow.\"), mdx(\"h4\", null, \"A. Checking Kitty Owner\"), mdx(\"p\", null, \"As we create functions which modify objects in storage, we should always check first that only the\\nappropriate users can successfully execute the logics in these dispatchable functions.\"), mdx(\"p\", null, \"The general pattern for an ownership check will look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"let owner = Self::owner_of(object_id).ok_or(\\\"No owner for this object\\\")?;\\n\\nensure!(owner == sender, \\\"You are not the owner\\\");\\n\")), mdx(\"p\", null, \"The first line checks if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Self::owner_of(object_id)\"), \" return a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Some(val)\"), \". If yes, it is\\ntransformed into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Result::Ok(val)\"), \", and finally extract \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"val\"), \" out from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Result\"), \". If not, it is\\ntransformed into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Result::Err()\"), \" with provided error message, and return early with the error\\nobject.\"), mdx(\"p\", null, \"The second line checks if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"owner == sender\"), \". If true, the program execution continues to the next\\nline. If not, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Result::Err(\\\"You are not the owner\\\")\"), \" error object is immediately returned from the\\nfunction.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Your turn!\")), mdx(\"p\", null, \"Paste in this code snippet to replace ACTION #1a:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"ensure!(Self::is_kitty_owner(&kitty_id, &sender)?, <Error<T>>::NotKittyOwner);\\n\")), mdx(\"p\", null, \"Paste the following in ACTION #1b:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"pub fn is_kitty_owner(kitty_id: &T::Hash, acct: &T::AccountId) -> Result<bool, Error<T>> {\\n    match Self::kitties(kitty_id) {\\n        Some(kitty) => Ok(kitty.owner == *acct),\\n        None => Err(<Error<T>>::KittyNotExist)\\n    }\\n}\\n\")), mdx(\"p\", null, \"The line pasted in ACTION #1b is actually combining two checks together. In case\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Self::is_kitty_owner()\"), \" returns an error object \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Err(<Error<T>>::KittyNotExist)\"), \", it is returned\\nearly with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Error<T>>::KittyNotExist\"), \" by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"?\"), \". If it returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Ok(bool_val)\"), \", the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bool_val\"), \"\\nis extracted, and if false, returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Error<T>>::NotKittyOwner\"), \" error.\"), mdx(\"h4\", null, \"B. Updating the price of our Kitty object\"), mdx(\"p\", null, \"Every Kitty object has a price attribute that we've set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \" as a default value inside the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mint\"), \" function \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#write-the-mint-function\"\n  }, \"earlier in this tutorial\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"let kitty = Kitty::<T> {\\n  dna: dna.unwrap_or_else(Self::gen_dna),\\n  price: None,                           //<-- \\uD83D\\uDC40 here\\n  gender: gender.unwrap_or_else(Self::gen_gender),\\n  owner: owner.clone(),\\n};\\n\")), mdx(\"p\", null, \"To update the price of a Kitty, we'll need to:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Get the Kitty object in storage.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Update the object with the new price.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Save it back into storage.\")), mdx(\"p\", null, \"Changing a value in an existing object in storage would be written in the following way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"let mut object = Self::get_object(object_id);\\nobject.value = new_value;\\n\\n<Object<T>>::insert(object_id, object);\\n\")), mdx(\"br\", null), mdx(Message, {\n    type: \"gray\",\n    title: \"Note\",\n    text: \"\\nRust expects you to declare a variable as mutable (using the `mut` keyword) whenever its value is\\ngoing to be updated.\\n\",\n    mdxType: \"Message\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Your turn!\")), mdx(\"p\", null, \"Paste in the following snippet to replace the ACTION #2 line:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"kitty.price = new_price.clone();\\n<Kitties<T>>::insert(&kitty_id, kitty);\\n\")), mdx(\"h4\", null, \"D. Deposit an Event\"), mdx(\"p\", null, \"Once all checks are passed and the new price is written to storage, we can deposit an event\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#implement-pallet-events\"\n  }, \"just like we did before\"), \".\\nReplace the line marked as ACTION #3 with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"// Deposit a \\\"PriceSet\\\" event.\\nSelf::deposit_event(Event::PriceSet(sender, kitty_id, new_price));\\n\")), mdx(\"p\", null, \"Now whenever the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set_price\"), \" dispatchable is called successfully, it will emit a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PriceSet\"), \" event.\"), mdx(\"h3\", {\n    \"id\": \"transfer-a-kitty\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#transfer-a-kitty\",\n    \"aria-label\": \"transfer a kitty permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Transfer a Kitty\"), mdx(\"p\", null, \"Based on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"create_kitty\"), \" function we built earlier, you already have the tools and knowledge\\nyou'll need to create the transfer functionality. The main difference is that there are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"two parts\"), \"\\nto achieving this:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"dispatchable function\"), \" called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"transfer()\"), \": this is a publicly callable dispatchable exposed\\nby your pallet.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"private helper function\"), \" called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"transfer_kitty_to()\"), \": this will be a private helper function\\ncalled by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"transfer()\"), \" to handle all storage updates when transferring a Kitty.\")), mdx(\"p\", null, \"Separating the logic this way makes the private \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transfer_kitty_to()\"), \" function reusable by other\\ndispatchable functions of our pallet without needing to duplicate code. In our case, we're going to\\nreuse it for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"buy_kitty\"), \" dispatchable we'll be creating next.\"), mdx(\"h4\", null, mdx(\"inlineCode\", {\n    parentName: \"h4\"\n  }, \"transfer\")), mdx(\"p\", null, \"Paste in the following snippet to replace ACTION #4 in the template code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::weight(100)]\\npub fn transfer(\\n    origin: OriginFor<T>,\\n    to: T::AccountId,\\n    kitty_id: T::Hash\\n) -> DispatchResult {\\n    let from = ensure_signed(origin)?;\\n\\n    // Ensure the kitty exists and is called by the kitty owner\\n    ensure!(Self::is_kitty_owner(&kitty_id, &from)?, <Error<T>>::NotKittyOwner);\\n\\n    // Verify the kitty is not transferring back to its owner.\\n    ensure!(from != to, <Error<T>>::TransferToSelf);\\n\\n    // Verify the recipient has the capacity to receive one more kitty\\n    let to_owned = <KittiesOwned<T>>::get(&to);\\n    ensure!((to_owned.len() as u32) < T::MaxKittyOwned::get(), <Error<T>>::ExceedMaxKittyOwned);\\n\\n    Self::transfer_kitty_to(&kitty_id, &to)?;\\n\\n    Self::deposit_event(Event::Transferred(from, to, kitty_id));\\n\\n    Ok(())\\n}\\n\")), mdx(\"p\", null, \"By now the above pattern should be familiar. We always check that the transaction is signed; then\\nwe verify that:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The Kitty being transferred is owned by the sender of this transaction;\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The Kitty is not transferred to its owner (a redundant operation);\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The recipient has the capacity to receive one more kitty;\")), mdx(\"p\", null, \"Lastly we call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transfer_kitty_to\"), \" helper to update all storage items appropriately.\"), mdx(\"h4\", null, mdx(\"inlineCode\", {\n    parentName: \"h4\"\n  }, \"transfer_kitty_to\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transfer_kitty_to\"), \" function will be a helper to perform all storage updates once a Kitty\\nis transferred (and it is going to be called when a kitty is bought and sold too). All it needs to\\ndo is perform safety checks and update the following storage items:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"KittiesOwned\"), \": to update the owner of the Kitty.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Kitties\"), \": to reset the price in the Kitty object to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"None\"), \".\")), mdx(\"p\", null, \"Copy the following to replace ACTION #5:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[transactional]\\npub fn transfer_kitty_to(\\n    kitty_id: &T::Hash,\\n    to: &T::AccountId,\\n) -> Result<(), Error<T>> {\\n    let mut kitty = Self::kitties(&kitty_id).ok_or(<Error<T>>::KittyNotExist)?;\\n\\n    let prev_owner = kitty.owner.clone();\\n\\n    // Remove `kitty_id` from the KittyOwned vector of `prev_kitty_owner`\\n    <KittiesOwned<T>>::try_mutate(&prev_owner, |owned| {\\n        if let Some(ind) = owned.iter().position(|&id| id == *kitty_id) {\\n            owned.swap_remove(ind);\\n            return Ok(());\\n        }\\n        Err(())\\n    }).map_err(|_| <Error<T>>::KittyNotExist)?;\\n\\n    // Update the kitty owner\\n    kitty.owner = to.clone();\\n    // Reset the ask price so the kitty is not for sale until `set_price()` is called\\n    // by the current owner.\\n    kitty.price = None;\\n\\n    <Kitties<T>>::insert(kitty_id, kitty);\\n\\n    <KittiesOwned<T>>::try_mutate(to, |vec| {\\n        vec.try_push(*kitty_id)\\n    }).map_err(|_| <Error<T>>::ExceedMaxKittyOwned)?;\\n\\n    Ok(())\\n}\\n\")), mdx(\"p\", null, \"Notice the use of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/attr.transactional.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"#[transactional]\")), \"\\nwhich we imported at the very beginning of this tutorial. It allows us to write dispatchable\\nfunctions that commit changes to the storage only if the annotated function returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Ok\"), \". Otherwise\\nall changes are discarded.\"), mdx(\"h3\", {\n    \"id\": \"buy-a-kitty\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#buy-a-kitty\",\n    \"aria-label\": \"buy a kitty permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Buy a Kitty\"), mdx(\"h4\", null, \"A. Check a Kitty is for sale\"), mdx(\"p\", null, \"We'll need to ensure two things before we can allow the user of this function to purchase a Kitty:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Check that the Kitty is for sale;\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Check whether the Kitty's current price is within the user's budget and whether the user has\\nenough free balance.\")), mdx(\"p\", null, \"Replace line ACTION #6:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"// Check the kitty is for sale and the kitty ask price <= bid_price\\nif let Some(ask_price) = kitty.price {\\n    ensure!(ask_price <= bid_price, <Error<T>>::KittyBidPriceTooLow);\\n} else {\\n    Err(<Error<T>>::KittyNotForSale)?;\\n}\\n\\n// Check the buyer has enough free balance\\nensure!(T::Currency::free_balance(&buyer) >= bid_price, <Error<T>>::NotEnoughBalance);\\n\")), mdx(\"p\", null, \"In a similar vain, we have to verify whether the user has the capacity to receive a Kitty \", \"\\u2014\", \"\\nremember we're using a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/bounded_vec/struct.BoundedVec.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"BoundedVec\")), \"\\nthat can only hold a fixed number of Kitties, defined in our pallet's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MaxKittyOwned\"), \" constant. Replace\\nACTION #7 with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"// Verify the buyer has the capacity to receive one more kitty\\nlet to_owned = <KittiesOwned<T>>::get(&buyer);\\nensure!((to_owned.len() as u32) < T::MaxKittyOwned::get(), <Error<T>>::ExceedMaxKittyOwned);\\n\\nlet seller = kitty.owner.clone();\\n\")), mdx(\"h4\", null, \"B. Making a payment\"), mdx(\"p\", null, \"In \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#2-transfer-a-kitty\"\n  }, \"Step 2\"), \", we added the functions necessary to transfer the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ownership\"), \" of our\\nKitties. But we haven't yet touched on the currrency system associated to our pallet.\"), mdx(\"p\", null, \"In this step we'll learn how to use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/traits/tokens/currency/index.html\"\n  }, \"FRAME's Currency trait\"), \" to adjust\\naccount balances using its \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://crates.parity.io/frame_support/traits/tokens/currency/trait.Currency.html#tymethod.transfer\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"transfer\"), \" method\"), \". It's useful to\\nunderstand why it's important to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transfer\"), \" method in particular and how we'll be accessing\\nit:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The reason we'll be using it is to ensure our runtime has the same understanding of currency throughout\\nthe pallets it interacts with. The way that we ensure this is to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Currency\"), \" trait given to us by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frame_support\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Conveniently, it handles a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/traits/tokens/currency/trait.Currency.html#associatedtype.Balance\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Balance\")), \" type, making it compatible with\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BalanceOf\"), \" type we created for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kitty.price\"), \". Take a look at how the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transfer\"), \" function we'll be\\nusing \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/traits/tokens/currency/trait.Currency.html#tymethod.transfer\"\n  }, \"is structured\"), \":\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"  fn transfer(\\n      source: &AccountId,\\n      dest: &AccountId,\\n      value: Self::Balance,\\n      existence_requirement: ExistenceRequirement\\n  ) -> DispatchResult\\n\")))), mdx(\"p\", null, \"Now we can make use of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Currency\"), \" type in our pallet's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Config\"), \" trait and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ExistenceRequirement\"), \"\\nthat we \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#write-out-pallet_kitties-scaffold\"\n  }, \"initially started with in the first section\"), \".\"), mdx(\"p\", null, \"Update the balances of both the caller of this function and the receiver, replacing ACTION #8:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"// Transfer the amount from buyer to seller\\nT::Currency::transfer(&buyer, &seller, bid_price, ExistenceRequirement::KeepAlive)?;\\n\\n// Transfer the kitty from seller to buyer\\nSelf::transfer_kitty_to(&kitty_id, &buyer)?;\\n\\n// Deposit relevant Event\\nSelf::deposit_event(Event::Bought(buyer, seller, kitty_id, bid_price));\\n\")), mdx(\"br\", null), mdx(Message, {\n    type: \"gray\",\n    title: \"Note\",\n    text: \"\\nBoth of the above operations, `T::Currency::transfer()`, and `Self::transfer_kitty_to()` could\\nfail which is why we check for the returned result in each case. If `Err` is returned, we also return from the\\nfunction immediately. In order to keep the storage consistent, we also annotate this function as\\n`#[transactional]`.\\n\",\n    mdxType: \"Message\"\n  }), mdx(\"h3\", {\n    \"id\": \"breed-kitties\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#breed-kitties\",\n    \"aria-label\": \"breed kitties permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Breed Kitties\"), mdx(\"p\", null, \"The logic behind breeding two Kitties is to multiply each corresponding DNA segment from two Kitties,\\nwhich will produce a new DNA sequence. Then, that DNA is used when minting a new Kitty. This helper\\nfunction is already provided for you in the template file for this section.\"), mdx(\"p\", null, \"Paste in the following to complete the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"breed_kitty\"), \" function, replacing line ACTION #9:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"let new_dna = Self::breed_dna(&parent1, &parent2)?;\\n\")), mdx(\"p\", null, \"Don't forget to add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"breed_dna(&parent1, &parent2)\"), \" helper function (peep it's definition in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/substrate-developer-hub/substrate-docs/blob/main/static/assets/tutorials/kitties-tutorial/04-interacting-functions.rs#L227\"\n  }, \"the helper file\"), \")\"), mdx(\"p\", null, \"Now that we've used the user inputs of Kitty IDs and combined them to create a new unique Kitty ID,\\nwe can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mint()\"), \" function to write that new Kitty to storage. Replace line ACTION #10 to\\ncomplete the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"breed_kitty\"), \" extrinsic:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"Self::mint(&sender, Some(new_dna), None)?;\\n\")), mdx(\"h3\", {\n    \"id\": \"genesis-configuration\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#genesis-configuration\",\n    \"aria-label\": \"genesis configuration permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Genesis configuration\"), mdx(\"p\", null, \"The final step before our pallet is ready to be used is to set the genesis state of our storage\\nitems. We'll make use of FRAME's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[pallet::genesis_config]\"), \" to do this. Essentially, this allows us\\nto declare what the Kitties object in storage contains in the genesis block. \"), mdx(\"p\", null, \"Copy the following code to replace ACTION #11:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"// Our pallet's genesis configuration.\\n#[pallet::genesis_config]\\npub struct GenesisConfig<T: Config> {\\n    pub kitties: Vec<(T::AccountId, [u8; 16], Gender)>,\\n}\\n\\n// Required to implement default for GenesisConfig.\\n#[cfg(feature = \\\"std\\\")]\\nimpl<T: Config> Default for GenesisConfig<T> {\\n    fn default() -> GenesisConfig<T> {\\n        GenesisConfig { kitties: vec![] }\\n    }\\n}\\n\\n#[pallet::genesis_build]\\nimpl<T: Config> GenesisBuild<T> for GenesisConfig<T> {\\n    fn build(&self) {\\n        // When building a kitty from genesis config, we require the dna and gender to be supplied.\\n        for (acct, dna, gender) in &self.kitties {\\n            let _ = <Pallet<T>>::mint(acct, Some(dna.clone()), Some(gender.clone()));\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"To let our chain know about our pallet's genesis configuration, we need to modify the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chain_spec.rs\"), \" file in our project's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node\"), \" folder. It's important you make sure you use\\nthe name of the pallet instance in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runtime/src/lib.rs\"), \", which in our case was \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SubstrateKitties\"), \".\\nGo to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node/src/chain_spec.rs\"), \", add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"use node_kitties_runtime::SubstrateKittiesConfig;\"), \" at the\\ntop of the file and add the following snippet inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"testnet_genesis\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"//-- snip --\\n        substrate_kitties: SubstrateKittiesConfig {\\n            kitties: vec![],\\n        },\\n//-- snip --\\n\")), mdx(\"h3\", {\n    \"id\": \"build-run-and-interact-with-your-kitties\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#build-run-and-interact-with-your-kitties\",\n    \"aria-label\": \"build run and interact with your kitties permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Build, run and interact with your Kitties\"), mdx(\"p\", null, \"If you've completed all of the preceding parts and steps of this tutorial, you're ready to\\nrun your chain and start interacting with all the new capabilities of your Kitties pallet!\"), mdx(\"p\", null, \"Build and run your chain using the following commands:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"cargo build --release\\n./target/release/node-kitties --dev --tmp\\n\")), mdx(\"p\", null, \"Now check your work using the Polkadot-JS Apps just like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#testing-with-polkadot-js-apps-ui\"\n  }, \"we did previously\"), \".\\nOnce your chain is running and connected to the PolkadotJS Apps UI, perform these manual checks:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fund multiple users with tokens so they can all participate\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Have each user create multiple Kitties\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Try to transfer a Kitty from one user to another using the right and wrong owner\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Try to set the price of a Kitty using the right and wrong owner\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Buy a Kitty using an owner and another user\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use too little funds to purchase a Kitty\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Overspend on the cost of the Kitty and ensure that the balance is reduced appropriately\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Breed a Kitty and check that the new DNA is a mix of the old and new\")), mdx(\"p\", null, \"After all of these actions, confirm that all users have the correct number of Kitties; that the total\\nKitty count is correct; and any other storage variables are correctly represented.\"), mdx(Message, {\n    type: \"green\",\n    title: \"Congratulations!\",\n    text: \"\\nYou've successfully created the backend of a fully functional Substrate chain capable of creating\\nand managing Substrate Kitties. The basic capabilities of our Kitties application could also be \\nabstracted to other NFT-like use cases. Most importantly, at this point in the tutorial you should \\nhave all the knowledge you need to start creating your own pallet logics and dispatchable functions.\\n\",\n    mdxType: \"Message\"\n  }), mdx(\"h2\", {\n    \"id\": \"next-steps\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#next-steps\",\n    \"aria-label\": \"next steps permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Next Steps\"), mdx(\"p\", null, \"Move on to Part II to connect your chain to the front-end template and create a user interface to\\nvisualize and interact with your Kitties!\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#tutorial-objectives","title":"Tutorial objectives","items":[{"url":"#what-were-building","title":"What we're building"},{"url":"#what-we-wont-cover","title":"What we won't cover"}]},{"url":"#basic-set-up","title":"Basic set-up","items":[{"url":"#set-up-your-template-node","title":"Set-up your template node"},{"url":"#write-the-pallet_kitties-scaffold","title":"Write the pallet_kitties scaffold"},{"url":"#add-storage-items","title":"Add storage items"},{"url":"#add-currency-implementation","title":"Add Currency implementation"}]},{"url":"#uniqueness-custom-types-and-storage-maps","title":"Uniqueness, custom types and storage maps","items":[{"url":"#scaffold-kitty-struct","title":"Scaffold Kitty struct"},{"url":"#write-a-custom-type-for-gender","title":"Write a custom type for Gender"},{"url":"#implement-on-chain-randomness","title":"Implement on-chain randomness"},{"url":"#write-remaining-storage-items","title":"Write remaining storage items"}]},{"url":"#dispatchables-events-and-errors","title":"Dispatchables, events, and errors","items":[{"url":"#public-and-private-functions","title":"Public and private functions"},{"url":"#write-the-create_kitty-dispatchable","title":"Write the create_kitty dispatchable"},{"url":"#write-the-mint-function","title":"Write the mint() function"},{"url":"#implement-pallet-events","title":"Implement pallet Events"},{"url":"#error-handling","title":"Error handling"},{"url":"#testing-with-polkadot-js-apps-ui","title":"Testing with Polkadot-JS Apps UI"}]},{"url":"#interacting-with-your-kitties","title":"Interacting with your Kitties","items":[{"url":"#set-a-price-for-each-kitty","title":"Set a price for each Kitty"},{"url":"#transfer-a-kitty","title":"Transfer a Kitty"},{"url":"#buy-a-kitty","title":"Buy a Kitty"},{"url":"#breed-kitties","title":"Breed Kitties"},{"url":"#genesis-configuration","title":"Genesis configuration"},{"url":"#build-run-and-interact-with-your-kitties","title":"Build, run and interact with your Kitties"}]},{"url":"#next-steps","title":"Next Steps"}]},"fileAbsolutePath":"/Users/a212/Desktop/substrate-docs/v3/tutorials/11-kitties-workshop/a-kitties-node/index.mdx"}},"pageContext":{"slug":"/tutorials/v3/kitties/pt1","version":"3.0","navMenuSlug":"kittiesWorkshop","locale":"en","hrefLang":"en-US","originalPath":"/tutorials/v3/kitties/pt1/","dateFormat":"MM/DD/YYYY"}},
    "staticQueryHashes": ["1239077767","1821483254","2966362950","3280999885"]}