{
    "componentChunkName": "component---src-templates-kb-template-tsx",
    "path": "/v3/runtime/benchmarking/",
    "result": {"data":{"mdx":{"frontmatter":{"slug":"/v3/runtime/benchmarking","title":"Benchmarking","hideNav":null,"section":"docs","category":"runtime"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Benchmarking\",\n  \"slug\": \"/v3/runtime/benchmarking\",\n  \"version\": 3,\n  \"section\": \"docs\",\n  \"category\": \"runtime\",\n  \"keywords\": \"benchmarking, optimizing, weights, runtime\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The default Substrate block production systems produce blocks at consistent intervals. This is the\\nknown as the target block time. Given this requirement, Substrate based blockchains are only be able\\nto execute a limited number of extrinsics per block. The time it takes to execute an extrinsic may\\nvary based on the computational complexity, storage complexity, hardware used, and many other\\nfactors. We use generic measurement called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/concepts/weight\"\n  }, \"weight\"), \" to represent how many extrinsics\\ncan fit into one block.\"), mdx(\"p\", null, \"In Substrate, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"10^12 weight units = 1 second\"), \", or 1,000 weight units = 1 nanosecond. This is measured on\\nspecific reference hardware: Intel Core i7-7700K CPU with 64GB of RAM and an NVMe SSD.\"), mdx(\"p\", null, \"Substrate does not use a mechanism similar to \\\"gas metering\\\" for extrinsic measurement due to the\\nlarge overhead such a process would introduce. Instead, Substrate expects benchmarking to provide an\\napproximate maximum for the worst case scenario of executing an extrinsic. Users are charged assuming\\nthis worst case scenario path was taken, and if the extrinsic turns out needing less resources, some of\\nthe estimated weight and fees can be returned. This is further explained in the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/weights-and-fees\"\n  }, \"Transaction Weights and Fees\"), \" chapter.\"), mdx(\"h2\", {\n    \"id\": \"why-benchmark-a-pallet\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#why-benchmark-a-pallet\",\n    \"aria-label\": \"why benchmark a pallet permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Why benchmark a pallet\"), mdx(\"p\", null, \"Denial-of-service (DoS) is a common attack vector for distributed systems, including blockchain\\nnetworks. A simple example of such an attack would be for a user to repeatedly execute an extrinsic\\nthat involve intensive computation. To prevent users from spamming the network, we charge fee to the\\nuser for making that call. The cost of the call should reflect the computation and storage cost\\nincurred to the system such that the more complex the call, the higher the fee. However, we still want to\\nencourage users to use our blockchain system, so we also want this estimated cost to be relatively\\naccurate so we don't charge users more than necessary.\"), mdx(\"p\", null, \"Benchmarking allows developers to charge appropriate transaction fees to end users, corresponding to a\\nmore accurate representation of the cost an extrinsic has on the system. Setting a proper weight function\\nthat accurately reflects the underlying computation and storage is also an important security safeguard in\\nSubstrate.\"), mdx(\"h2\", {\n    \"id\": \"how-to-benchmark\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#how-to-benchmark\",\n    \"aria-label\": \"how to benchmark permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"How to benchmark\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_benchmarking/benchmarking/index.html\"\n  }, \"FRAME benchmarking module\"), \" has a set\\nof tools to help determine the worst case scenario computation time of runtime extrinsics in order to\\ndetermine appropriate weights for those extrinsics. It does this by executing a pallet's extrinsics\\nmultiple times within a mock runtime environment, and keeps track of the execution time.\"), mdx(\"p\", null, \"In summary, it:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Sets up and executes extrinsics from your pallets.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Captures the raw data of these benchmarks over with these varying inputs, including how many\\ndatabase reads and writes have been performed.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Uses linear regression analysis to determine the relationship between computation time and the\\nextrinsic input.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Outputs a Rust file with ready to use weight functions that can be easily integrated in your\\nruntime.\"))), mdx(\"p\", null, \"This framework uses Rust macros to help developers easily integrate bencharking into their runtimes.\\nA Substrate benchmark will look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"benchmarks! {\\n  benchmark_name {\\n    /* set-up initial state */\\n  }: {\\n    /* the code to be benchmarked */\\n  } verify {\\n    /* verifying final state */\\n  }\\n}\\n\")), mdx(\"p\", null, \"You can see that the benchmark macro:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Sets up the initial state before running the benchmark.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Measures the execution time, along with the number of database reads and writes.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Verifies the final state of the runtime, ensuring that the benchmark executed as expected.\")), mdx(\"p\", null, \"You can configure your benchmark to run over different varying inputs. For each input, you can\\nconfigure the range of those variables, and use them within the benchmark set-up or execution logic.\"), mdx(\"p\", null, \"The full syntax and functionality can be seen in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_benchmarking/macro.benchmarks.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"benchmarks!\"), \" macro API\\ndocumentation\"), \".\"), mdx(\"h2\", {\n    \"id\": \"best-practices-and-common-patterns\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#best-practices-and-common-patterns\",\n    \"aria-label\": \"best practices and common patterns permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Best practices and common patterns\"), mdx(\"p\", null, \"There are a few best practices for writing extrinsics in order to avoid any surprise on your\\nextrinsics computation time and benchmarking.\"), mdx(\"h3\", {\n    \"id\": \"initial-weight-calculation-must-be-lightweight\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#initial-weight-calculation-must-be-lightweight\",\n    \"aria-label\": \"initial weight calculation must be lightweight permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Initial weight calculation must be lightweight\"), mdx(\"p\", null, \"Extrinsic weight function will be called, probably multiple times, when an extrinsic is going to be\\ncalled. So the weight function must be lightweight and should not perform any storage read/write, an\\nexpensive operation.\"), mdx(\"h3\", {\n    \"id\": \"set-bounds-and-assume-worst-case\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#set-bounds-and-assume-worst-case\",\n    \"aria-label\": \"set bounds and assume worst case permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Set bounds and assume worst case\"), mdx(\"p\", null, \"If the extrinsic computation time depends on an existing storage value, then set a maximum bound on\\nthose storage items and assume the worst case. Once the actual weight is known, the difference can be\\nreturned in the extrinsic.\"), mdx(\"h3\", {\n    \"id\": \"keep-extrinsics-simple\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#keep-extrinsics-simple\",\n    \"aria-label\": \"keep extrinsics simple permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Keep extrinsics simple\"), mdx(\"p\", null, \"Try to keep an extrinsic simple and to perform only one function. Sometimes it may be better to separate\\nthe complex logic into multiple extrinsic calls and have a front-end abstracting these extrinsic\\ninteractions away to provide a clean and friendly user experience.\"), mdx(\"h3\", {\n    \"id\": \"separate-benchmarks-per-logical-path-and-use-the-worst-case\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#separate-benchmarks-per-logical-path-and-use-the-worst-case\",\n    \"aria-label\": \"separate benchmarks per logical path and use the worst case permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Separate benchmarks per logical path and use the worst case\"), mdx(\"p\", null, \"If your extrinsic has multiple logical paths with signficantly different execution time, separate\\nthese paths in multiple benchmarking cases and measure them. In the actual pallet weight macro above\\nthe extrinsics, you could combine them with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"max\"), \" function, e.g.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::weight(\\n  <T::WeightInfo::path_a()\\n    .max(T::WeightInfo::path_b())\\n    .max(T::WeightInfo::path_c())>\\n)]\\n\")), mdx(\"p\", null, \"Note the weight returned here is more as the worst case of the weight estimate. You can then decide\\nif you want to return some weight value back at the end of the extrinsic once you know what computations\\nhave happened. Otherwise it will be always overcharging users for calling this extrinsic.\"), mdx(\"h3\", {\n    \"id\": \"minimize-usage-of-on_finalize-and-transition-logic-to-on_initialize\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#minimize-usage-of-on_finalize-and-transition-logic-to-on_initialize\",\n    \"aria-label\": \"minimize usage of on_finalize and transition logic to on_initialize permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Minimize usage of \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"on_finalize\"), \", and transition logic to \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"on_initialize\")), mdx(\"p\", null, \"Substrate provides runtime developers with multiple hooks when writing their own runtime, with\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_initialize\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_finalize\"), \" being two of them. As \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_finalize\"), \" is the last thing that happens in\\na block, variable weight requirements in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_finalize\"), \" can easily lead to an overweight block and should be\\navoided.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"907px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"17.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA3UlEQVQI14XDPUsCcQDA4f/Y0pKDL5011OqUFAlaJ3qpFXacEKfOClpQIJKXDt2QL8X1YtzRcWEvJA43tLX51X5+BB94hBCCZUOhMOvRDYIRiaC0ycpqgKJe4n/+h+e88fE05ndoM2h2EbuxE7TTOzKFDgdnJkn9kb2KyX7zgWTXJt13KLy4qCOL2uszHduiPx7QNlq0b1r0bg2qeoWsfEQqISNS8XN0bUS+aJKr2ij1Lw4bDrIxQbF8jt991G+fsjfh+ueT+6mHO3O5vLognVFQtRKxnThrUpTI1jYLgMt3mR1GwFsAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"on-finalize-blocktime.png\",\n    \"title\": \"on-finalize-blocktime.png\",\n    \"src\": \"/static/bed84591689cf1f060e0886e8776f0f0/142fb/benchmarking-on-finalize-blocktime.png\",\n    \"srcSet\": [\"/static/bed84591689cf1f060e0886e8776f0f0/5a46d/benchmarking-on-finalize-blocktime.png 300w\", \"/static/bed84591689cf1f060e0886e8776f0f0/0a47e/benchmarking-on-finalize-blocktime.png 600w\", \"/static/bed84591689cf1f060e0886e8776f0f0/142fb/benchmarking-on-finalize-blocktime.png 907w\"],\n    \"sizes\": \"(max-width: 907px) 100vw, 907px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \")), mdx(\"p\", null, \"If possible, move the logic to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_intialize\"), \" hook that happens at the beginning of the block. Then\\nthe number of extrinsics to be included in the block can be adjusted accordingly. Another trick is\\nto put the weight of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_finalize\"), \" on to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_initialize\"), \" or the extrinsic itself. This leads to\\nanother tip of trying to keep the pallet hook execution in constant time for only set up and clean\\nup, but not doing fancy computation.\"), mdx(\"h2\", {\n    \"id\": \"command-arguments\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#command-arguments\",\n    \"aria-label\": \"command arguments permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Command arguments\"), mdx(\"p\", null, \"To find out what the different CLI commands do, run:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \" cargo build --features runtime-benchmarks --help\\n\")), mdx(\"p\", null, \" Here's an example of launching a node with benchmarking features enabled:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \" ./target/release/node-template benchmark \\\\  \\n    --chain dev \\\\               # Configurable Chain Spec\\n    --execution wasm \\\\          # Always test with Wasm\\n    --wasm-execution compiled \\\\ # Always used `wasm-time`\\n    --pallet pallet_example \\\\   # Select the pallet\\n    --extrinsic '\\\\*' \\\\          # Select the benchmark case name, using '*' for all\\n    --steps 20 \\\\                # Number of steps across component ranges\\n    --repeat 10 \\\\               # Number of times we repeat a benchmark\\n    --raw \\\\                     # Optionally output raw benchmark data to stdout\\n    --output ./                 # Output results into a Rust file\\n\")), mdx(\"p\", null, \"A recent argument that has been introduced is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--template\"), \". With it, you can specify your own weight\\ntemplate file and the benchmarking toolchain will fill in the exact numbers from the measured\\nresult. This enables automating weight generation in your desired code format and integrates this\\nin your CI process.\"), mdx(\"p\", null, \"The template is in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.rs/handlebars/\"\n  }, \"rust handlebars\"), \" format.\"), mdx(\"h2\", {\n    \"id\": \"example\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#example\",\n    \"aria-label\": \"example permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Example\"), mdx(\"p\", null, \"Let's take \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"accumulate_dummy\"), \" benchmark case from the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/substrate/blob/4b6635cf136a9fe2226f3152b4633afc6269912c/frame/example/src/lib.rs#L501-L530\"\n  }, \"example pallet\"), \"\\nas an example. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"accumulate_dummy {\\n  let b in 1 .. 1000;\\n  let caller = account(\\\"caller\\\", 0, 0);\\n}: _ (RawOrigin::Signed(caller), b.into())\\n\")), mdx(\"p\", null, \"Using the benchmarking CLI, we can specify the number of steps and repeats. This means how many\\nsteps will be taken to walk through each variable range, and how many times the execution state\\nwill be repeated.\"), mdx(\"p\", null, \"For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"./target/release/node-template benchmark \\\\\\n    --chain dev \\\\               \\n    --execution wasm \\\\          \\n    --wasm-execution compiled \\\\ \\n    --pallet pallet_example \\\\  \\n    --extrinsic '\\\\*' \\\\          \\n    --steps 20 \\\\                \\n    --repeat 10 \\\\               \\n    --raw \\\\                     \\n    --output ./pallets/example/weights.rs                 \\n\")), mdx(\"p\", null, \"With \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--steps 20 --repeat 10\"), \" in the benchmark input arguments, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" will walk 20 steps to reach\\n1,000, so \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" will start from 1 and increment by about 50. For each value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \", we will execute\\nthe benchmark 10 times and record the benchmark information. The resulting weights will be outputted\\ninto a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"weights.rs\"), \" file.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1039px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"55.99999999999999%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABzElEQVQoz3WSyW7UQBRFXa8GuyaP3ekMAnXSSiJYAGIQEYJ1lgyK8v9/cpDL3R2CYHF17bJ13nCr6rqO3W7H5dUl2+0Way1VVf1TIoJS6vm5qtBKF5X3m+sbHh8eefj1wI/vP0kp/RdYiu0BViy11EQd8eJxyi3/Zddyms/YtBs2YYNRZunGapTTKKup9l1ZYzm3F/R6oNZ1gRptUKJKoQL0EhjcwBhGejMwyFg+hKlldXXOtD3D5aacDWaiM/0RMI8/S2av9quIJrEOa1ZxRe96kmRildje7vh8d8enb3dsTs9pq5bo0hEkWqOtRTtXXIzZA3Vk1ayYwsRohlIpVJHr3S3v7r/w+sNbLsYXy8i+xjYe4z2maZAZWNcFKocwm5To1iekcSSOE6KXSi+vtry//8qrj2+I3RKUnrs6SKRIRBU/pl/nTD45IQwDYZpQ+9adb0hjh63dsrM5KP0UUPG/VToMgW7oSTmRuo5K5HhNXB+eXZvGOWpRWFXhnknh5BCK1qx9wyp6JmcJztEPA9klYu6JwdPOOzMWowQnglEzdJH5wxdgahjaQN9F2lgTciijxpzxfUvsE7GN1ClgvMOEBhPqIhsPz3v3jt/lWfOB/f875wAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"multi-variables-regression\",\n    \"title\": \"multi-variables-regression\",\n    \"src\": \"/static/f086d0603daf8215be12857d9ddd9b9d/22475/benchmarking-multi-variables-regression.png\",\n    \"srcSet\": [\"/static/f086d0603daf8215be12857d9ddd9b9d/5a46d/benchmarking-multi-variables-regression.png 300w\", \"/static/f086d0603daf8215be12857d9ddd9b9d/0a47e/benchmarking-multi-variables-regression.png 600w\", \"/static/f086d0603daf8215be12857d9ddd9b9d/22475/benchmarking-multi-variables-regression.png 1039w\"],\n    \"sizes\": \"(max-width: 1039px) 100vw, 1039px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \")), mdx(\"h3\", {\n    \"id\": \"raw-data-output\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#raw-data-output\",\n    \"aria-label\": \"raw data output permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Raw data output\"), mdx(\"p\", null, \"The first output is the raw data recording how much time is spent on running the execution state\\nwhen varying the input variables. At the end for each variable, the coefficient, assuming linear\\nrelationship, between the execution time with respect to change in the variable is determined.\"), mdx(\"p\", null, \"This is a snippet of the output:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csv\"\n  }, \"Pallet: \\\"pallet_example\\\", Extrinsic: \\\"accumulate_dummy\\\", Lowest values: [], Highest values: [], Steps: [10], Repeat: 5\\nb,extrinsic_time,storage_root_time,reads,repeat_reads,writes,repeat_writes\\n1,1231926,162640,1,4,1,2\\n1,1245146,128021,1,4,1,2\\n1,1238746,126051,1,4,1,2\\n1,1206004,126391,1,4,1,2\\n1,1212564,127941,1,4,1,2\\n100,1257646,129750,1,4,1,2\\n100,1232476,125780,1,4,1,2\\n100,1215466,128310,1,4,1,2\\n100,1205835,129070,1,4,1,2\\n...\\n991,1208294,125820,1,4,1,2\\n991,1209305,126921,1,4,1,2\\n991,1203275,125031,1,4,1,2\\n991,1234855,124190,1,4,1,2\\n991,1337136,125060,1,4,1,2\\n\\nMedian Slopes Analysis\\n========\\n-- Extrinsic Time --\\n\\nModel:\\nTime ~=     1231\\n    + b        0\\n              \\xB5s\\n\\nReads = 1 + (0 * b)\\nWrites = 1 + (0 * b)\\n\\nMin Squares Analysis\\n========\\n-- Extrinsic Time --\\n\\nData points distribution:\\n    b   mean \\xB5s  sigma \\xB5s       %\\n    1      1230     12.61    1.0%\\n  100      1230     16.53    1.3%\\n  199      1227     12.88    1.0%\\n  298      1215     12.94    1.0%\\n  397      1239     19.83    1.6%\\n  496      1234     18.51    1.5%\\n  595      1228     7.167    0.5%\\n  694      1233     13.51    1.0%\\n  793      1218     9.876    0.8%\\n  892      1225     14.15    1.1%\\n  991      1220     11.63    0.9%\\n\\nQuality and confidence:\\nparam     error\\nb         0.006\\n\\nModel:\\nTime ~=     1230\\n    + b        0\\n              \\xB5s\\n\\nReads = 1 + (0 * b)\\nWrites = 1 + (0 * b)\\n\")), mdx(\"p\", null, \"With the median slopes analysis, this is the weight function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"1231 \\xB5s + (0 * b) +\\n  [1 + (0 * b)] * db read time +\\n  [1 + (0 * b)] * db write time\\n\")), mdx(\"p\", null, \"We separate the db/storage read and write out because they are particularly expensive and their\\nrespective operation time will be retrieved from the runtime. We just need to measure how many db\\nread write are performed with respect to the change of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \".\"), mdx(\"p\", null, \"The benchmark result is telling us that it will always perform 1 db read and 1 db write no matter\\nhow \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" changes.\"), mdx(\"p\", null, \"The benchmark library gives us both a median slope analysis; that the execution time of a particular\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" value is taken as the median value of the repeated runs, and a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Least_squares\"\n  }, \"min. square\\nanalysis\"), \" that is better explained in a statistics\\nprimer.\"), mdx(\"p\", null, \"You can also derive your own coefficients given you have the raw data on each run, say maybe you\\nknow the computation time will not be a linear but an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"O(nlogn)\"), \" relationship with the input\\nvariable. So you need to determine the coefficient differently.\"), mdx(\"h3\", {\n    \"id\": \"auto-generated-weightinfo-implementation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#auto-generated-weightinfo-implementation\",\n    \"aria-label\": \"auto generated weightinfo implementation permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Auto-generated \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"WeightInfo\"), \" implementation\"), mdx(\"p\", null, \"The second output is an auto-generated \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WeightInfo\"), \" implementation. This file defines weight\\nfunctions of benchmarked extrinsics with the computed coefficient above. We can directly integrated\\nthis file in your pallet or further customize them if so desired. The auto-generated implementation\\nis designed to make end-to-end weight updates easy.\"), mdx(\"p\", null, \"To use this file, we define a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WeightInfo\"), \" trait, for example in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/frame#example\"\n  }, \"Example pallet\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"pub trait WeightInfo {\\n  fn accumulate_dummy(b: u32, ) -> Weight;\\n  fn set_dummy(b: u32, ) -> Weight;\\n  fn sort_vector(x: u32, ) -> Weight;\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"further-learning\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#further-learning\",\n    \"aria-label\": \"further learning permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Further learning\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/paritytech/substrate/blob/master/frame/benchmarking/README.md\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"frame-benchmarking\"), \" README\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.youtube.com/watch?v=Qa6sTyUqgek\"\n  }, \"Substrate Seminar: Benchmarking Your Substrate\\nPallet\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-to-guides/v3/weights/use-benchmark-weights\"\n  }, \"Learn how to use benchmarking to configure the weights for your pallet's extrinsics\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#why-benchmark-a-pallet","title":"Why benchmark a pallet"},{"url":"#how-to-benchmark","title":"How to benchmark"},{"url":"#best-practices-and-common-patterns","title":"Best practices and common patterns","items":[{"url":"#initial-weight-calculation-must-be-lightweight","title":"Initial weight calculation must be lightweight"},{"url":"#set-bounds-and-assume-worst-case","title":"Set bounds and assume worst case"},{"url":"#keep-extrinsics-simple","title":"Keep extrinsics simple"},{"url":"#separate-benchmarks-per-logical-path-and-use-the-worst-case","title":"Separate benchmarks per logical path and use the worst case"},{"url":"#minimize-usage-of-on_finalize-and-transition-logic-to-on_initialize","title":"Minimize usage of on_finalize, and transition logic to on_initialize"}]},{"url":"#command-arguments","title":"Command arguments"},{"url":"#example","title":"Example","items":[{"url":"#raw-data-output","title":"Raw data output"},{"url":"#auto-generated-weightinfo-implementation","title":"Auto-generated WeightInfo implementation"}]},{"url":"#further-learning","title":"Further learning"}]},"fileAbsolutePath":"/Users/a212/Desktop/substrate-docs/v3/docs/03-runtime/i-benchmarking/index.mdx"}},"pageContext":{"slug":"/v3/runtime/benchmarking","version":"3.0","locale":"en","hrefLang":"en-US","originalPath":"/v3/runtime/benchmarking/","dateFormat":"MM/DD/YYYY"}},
    "staticQueryHashes": ["1239077767","1821483254","2966362950","3280999885"]}