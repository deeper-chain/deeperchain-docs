{
    "componentChunkName": "component---src-templates-kb-template-tsx",
    "path": "/v3/runtime/storage/",
    "result": {"data":{"mdx":{"frontmatter":{"slug":"/v3/runtime/storage","title":"Storage","hideNav":null,"section":"docs","category":"runtime"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Storage\",\n  \"slug\": \"/v3/runtime/storage\",\n  \"version\": 3,\n  \"section\": \"docs\",\n  \"category\": \"runtime\",\n  \"keywords\": null\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Message = makeShortcode(\"Message\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Runtime storage allows you to store data in your blockchain that is persisted between blocks and can\\nbe accessed from within your runtime logic. Storage should be one of the most critical concerns of a\\nblockchain runtime developer. Well designed storage systems reduce the load on nodes in the network, which\\nultimately lowers the overhead costs for participants in your blockchain. In other words, the fundamental principle of blockchain runtime storage is to minimize its use.\"), mdx(\"p\", null, \"Substrate exposes a set of layered, modular storage APIs that allow runtime developers to make the storage decisions that suit them\\nbest. This\\ndocument is intended to provide information and best practices about Substrate's runtime storage\\ninterfaces. Please refer to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/advanced/storage\"\n  }, \"the advanced storage documentation\"), \" for information about how these interfaces are implemented.\"), mdx(\"h2\", {\n    \"id\": \"storage-items\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#storage-items\",\n    \"aria-label\": \"storage items permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Storage items\"), mdx(\"p\", null, \"In Substrate, any pallet can introduce new storage items that will become part of your blockchain\\u2019s state. These storage items can be simple single value items, or more complex storage maps. The type of storage items you choose to implement depends entirely on their intended role within your runtime logic.\"), mdx(\"p\", null, \"FRAME's \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/index.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Storage\"), \" module\"), \" gives runtime developers access to Substrate's flexible storage APIs, which can support any value that is encodable\\nby \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/advanced/scale-codec/index.html\"\n  }, \"Parity's SCALE codec\"), \". These include:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.StorageValue.html\"\n  }, \"Storage Value\"), \" - used to store any single value, such as a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"u64\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.StorageMap.html\"\n  }, \"Storage Map\"), \" - used to store a key-value hash map, such as a balance-to-account mapping.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.StorageDoubleMap.html\"\n  }, \"Storage Double Map\"), \" - used as an implementation of a storage map with two keys to provide the ability to efficiently removing\\nall entries that have a common first key.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.StorageNMap.html\"\n  }, \"Storage N Map\"), \" - used to store a hash map with any arbitrary number of keys, it can be used as a basis to build a Triple Storage Map, a Quadruple Storage Map and so on.\")), mdx(\"h3\", {\n    \"id\": \"storage-value\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#storage-value\",\n    \"aria-label\": \"storage value permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Storage value\"), mdx(\"p\", null, \"This type of storage item should be used for values that are viewed as a single unit by the runtime. This could be a single primitive value, a single \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"struct\"), \", or a single collection of related\\nitems. If a storage item is used for storing lists of items, runtime developers should be conscious about the size of the lists they use.\\nLarge lists incur storage costs just like large \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"structs\"), \".\\nFurthermore, iterating over a large list in your runtime may result in exceeding the block production time. If this occurs your blockchain\\nwill stop producing blocks, which means that it will stop functioning.\"), mdx(Message, {\n    type: \"yellow\",\n    title: \"Important\",\n    text: \"Although wrapping related items in a shared `struct` is an excellent way to reduce the number\\n  of storage reads, at some point the size of the object will begin to\\n  incur costs that may outweigh the optimization in storage reads. Read more about [benchmarking](/v3/runtime/benchmarking) to learn\\n  how to optimize execution time.\",\n    mdxType: \"Message\"\n  }), mdx(\"p\", null, \"Refer to the Storage Value documentation for\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.StorageValue.html#required-methods\"\n  }, \"a comprehensive list of the methods that Storage Value exposes\"), \".\"), mdx(\"h3\", {\n    \"id\": \"storage-map\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#storage-map\",\n    \"aria-label\": \"storage map permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Storage map\"), mdx(\"p\", null, \"Map data structures are ideal for managing sets of items whose elements will be accessed randomly,\\nas opposed to iterating over them sequentially in their entirety. Storage Maps in Substrate are\\nimplemented as key-value hash maps. In order to give runtime engineers increased control, Substrate allows developers to select\\nwhich hashing algorithms suits their use case the best for generating a map's keys. This is covered in the section on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#hashing-algorithms\"\n  }, \"hashing algorithms\"), \".\"), mdx(\"p\", null, \"Refer to the Storage Map documentation for\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.StorageMap.html#required-methods\"\n  }, \"a comprehensive list of the methods that Storage Map exposes\"), \".\"), mdx(\"h3\", {\n    \"id\": \"double-storage-map\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#double-storage-map\",\n    \"aria-label\": \"double storage map permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Double storage map\"), mdx(\"p\", null, \"Double Storage Maps are very similar to single Storage Maps except they contain two keys, which is useful for querying values with common keys.\"), mdx(\"p\", null, \"Refer to the documentation on\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/advanced/storage\"\n  }, \"advanced storage\"), \" to learn more about how different Storage Maps, including Double Storage Maps, are implemented.\"), mdx(\"h3\", {\n    \"id\": \"n-storage-map\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#n-storage-map\",\n    \"aria-label\": \"n storage map permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"N storage map\"), mdx(\"p\", null, \"N Storage Maps are also very similar to its siblings, namely Storage Maps and Double Storage Maps, but with the ability to hold any arbitrary number of keys.\"), mdx(\"p\", null, \"To specify the keys in an N Storage Map in FRAMEv2, a tuple containing the special \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NMapKey\"), \" struct must be provided as a type to the Key (i.e. second) type parameter while declaring the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StorageNMap\"), \".\"), mdx(\"p\", null, \"Refer to the N Storage Map documentation for more details about the syntaxes in using a N Storage Map.\"), mdx(\"h4\", null, \"Iterating over storage maps\"), mdx(\"p\", null, \"Substrate Storage Maps are iterable with respect to their keys and values. Because maps are often\\nused to track unbounded sets of data (such as account balances), iterating over them without caution in the runtime may cause blocks not being able to produced in time.\\nFurthermore, because accessing the elements of a map requires more database reads than accessing the\\nelements of a native list, map iterations are significantly \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"more\"), \" costly than list iterations in terms of execution time.\"), mdx(Message, {\n    type: \"green\",\n    title: \"A note on best practices\",\n    text: \"In general, Substrate focuses on \\\"[first principles](#best-practices)\\\" as opposed to hard and fast rules\\n  of right and wrong. The information here aims to help you understand _all_ of Substrate's\\n  storage capabilities and how to use them in a way that respects the principles around which\\n  they were designed. For instance, iterating over storage maps in your runtime is neither right nor \\n  wrong &mdash; yet, avoiding it would be considered a better approach with respect to best practices.\",\n    mdxType: \"Message\"\n  }), mdx(\"p\", null, \"Substrate's Iterable Storage Map interfaces define the following methods (note that for Iterable\\nStorage Double Maps, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"drain()\"), \" methods require the first key as a parameter):\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iter()\"), \" - enumerate all elements in the map in no particular order. If you alter the map while\\ndoing this, you'll get undefined results. See the docs:\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.IterableStorageMap.html#tymethod.iter\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"IterableStorageMap\")), \",\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.IterableStorageDoubleMap.html#tymethod.iter\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"IterableStorageDoubleMap\")), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IterableStorageNMap\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"drain()\"), \" - remove all elements from the map and iterate through them in no particular order. If you\\nadd elements to the map while doing this, you'll get undefined results. See the docs:\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.IterableStorageMap.html#tymethod.drain\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"IterableStorageMap\")), \",\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.IterableStorageDoubleMap.html#tymethod.drain\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"IterableStorageDoubleMap\")), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IterableStorageNMap\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"translate()\"), \" - use the provided function to translate all elements of the map, in no particular\\norder. To remove an element from the map, return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"None\"), \" from the translation function. See the docs:\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.IterableStorageMap.html#tymethod.translate\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"IterableStorageMap\")), \",\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/trait.IterableStorageDoubleMap.html#tymethod.translate\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"IterableStorageDoubleMap\")), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IterableStorageNMap\"), \".\")), mdx(\"h2\", {\n    \"id\": \"declaring-storage-items\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#declaring-storage-items\",\n    \"aria-label\": \"declaring storage items permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Declaring storage items\"), mdx(\"p\", null, \"Runtime storage items are created with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/attr.pallet.html#storage-palletstorage-optional\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"#[pallet::storage]\")), \"\\nin any FRAME-based pallet. Here is an example of declaring the 3 different types of storage items:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::storage]\\ntype SomePrivateValue<T> = StorageValue<_, u32, ValueQuery>;\\n\\n#[pallet::storage]\\n#[pallet::getter(fn some_primitive_value)]\\npub(super) type SomePrimitiveValue<T> = StorageValue<_, u32, ValueQuery>;\\n\\n#[pallet::storage]\\npub(super) type SomeComplexValue<T> = StorageValue<_, T::AccountId, ValueQuery>;\\n\\n#[pallet::storage]\\n#[pallet::getter(fn some_map)]\\npub(super) type SomeMap<T> = StorageMap<_, Blake2_128Concat, T::AccountId, u32, ValueQuery>;\\n\\n#[pallet::storage]\\npub(super) type SomeDoubleMap<T> = StorageDoubleMap<_, Blake2_128Concat, u32, Blake2_128Concat, T::AccountId, u32, ValueQuery>;\\n\\n#[pallet::storage]\\n#[pallet::getter(fn some_nmap)]\\npub(super) type SomeNMap<T> = StorageNMap<\\n    _,\\n    (\\n        NMapKey<Blake2_128Concat, u32>,\\n        NMapKey<Blake2_128Concat, T::AccountId)>,\\n        NMapKey<Twox64Concat, u32>,\\n    ),\\n    u32,\\n    ValueQuery,\\n>;\\n\")), mdx(\"p\", null, \"Notice that the map's storage items specify \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#hashing-algorithms\"\n  }, \"the hashing algorithm\"), \" that will\\nbe used.\"), mdx(\"h3\", {\n    \"id\": \"querykindtrait\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#querykindtrait\",\n    \"aria-label\": \"querykindtrait permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"QueryKindTrait\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/types/trait.QueryKindTrait.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"QueryKindTrait\")), \" generic of storage determines\\nhow the storage should be handled when there is no value in storage. With \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/types/struct.OptionQuery.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"OptionQuery\")), \", when no value is in storage\\nthe method get will return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \". With \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/types/struct.ValueQuery.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"ValueQuery\")), \",\\nwhen no value is in storage the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get\"), \" method will return the value configured with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OnEmpty\"), \" generic.\\nWhen you have a specific default value to configure, use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ValueQuery\"), \".\"), mdx(\"h3\", {\n    \"id\": \"visibility\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#visibility\",\n    \"aria-label\": \"visibility permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Visibility\"), mdx(\"p\", null, \"In the examples above, all the storage items except \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SomePrivateValue\"), \" are made public by way of the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pub\"), \" keyword. Blockchain storage is always publicly\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#accessing-storage-items\"\n  }, \"visible from \", mdx(\"em\", {\n    parentName: \"a\"\n  }, \"outside\"), \" of the runtime\"), \"; the visibility of Substrate\\nstorage items only impacts whether or not other pallets \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"within\"), \" the runtime will be able to access\\na storage item.\"), mdx(\"h3\", {\n    \"id\": \"getter-methods\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#getter-methods\",\n    \"aria-label\": \"getter methods permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Getter methods\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[pallet::getter(..)]\"), \" macro provides an optional \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get\"), \" extension that can be used to implement a getter\\nmethod for a storage item on the module that contains that storage item; the extension takes the\\ndesired name of the getter function as an argument. If you omit this optional extension, you will\\nstill be able to access the storage item's value, but you will not be able to do so by way of a\\ngetter method implemented on the module; instead, you will need to use\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#methods\"\n  }, \"the storage item's \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"get\"), \" method\"), \".\"), mdx(Message, {\n    type: \"gray\",\n    title: \"Note\",\n    text: \"The optional `get` and `getter` extensions only\\n  impact the way that a storage item can be accessed from _within_ Substrate code &mdash; you will always be\\n  able to [query the storage of your runtime](/v3/advanced/storage#Querying-Storage) to get the value\\n  of a storage item.\",\n    mdxType: \"Message\"\n  }), mdx(\"p\", null, \"Here is an example that implements a getter method named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"some_value\"), \" for a Storage Value named\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SomeValue\"), \". This pallet would now have access to a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Self::some_value()\"), \" method in addition to the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SomeValue::get()\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::storage]\\n#[pallet::getter(fn some_value)]\\npub(super) type SomeValue = StorageValue<_, u64, ValueQuery>;\\n\")), mdx(\"h3\", {\n    \"id\": \"default-values\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#default-values\",\n    \"aria-label\": \"default values permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Default values\"), mdx(\"p\", null, \"Substrate allows you to specify a default value that is returned when a storage item's value is not\\nset. Although the default value does \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" actually occupy runtime storage, the runtime logic will see this\\nvalue during execution.\"), mdx(\"p\", null, \"Here is an example of specifying the default value for all items in a map:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::type_value]\\npub fn MyDefaultMap<T: Config>() -> u64 { 1337u64 }\\n#[pallet::storage]\\npub type MyStorage<T> = StorageMap<_, Blake2_128Concat, u64, u64, ValueStorage, MyDefaultMap>;\\n\")), mdx(\"h2\", {\n    \"id\": \"accessing-storage-items\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#accessing-storage-items\",\n    \"aria-label\": \"accessing storage items permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Accessing storage items\"), mdx(\"p\", null, \"Blockchains that are built with Substrate expose a remote procedure call (RPC) server that can be\\nused to query runtime storage. You can use software libraries like\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://polkadot.js.org/\"\n  }, \"Polkadot JS\"), \" to easily interact with the RPC server from your code and\\naccess storage items. The Polkadot JS team also maintains\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://polkadot.js.org/apps\"\n  }, \"the Polkadot Apps UI\"), \", which is a fully-featured web app for\\ninteracting with Substrate-based blockchains, including querying storage.\"), mdx(\"p\", null, \"Refer to\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/advanced/storage\"\n  }, \"the advanced storage documentation\"), \" to learn more about how to query a Substrate key-value database by using the RPC server.\"), mdx(\"h2\", {\n    \"id\": \"hashing-algorithms\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#hashing-algorithms\",\n    \"aria-label\": \"hashing algorithms permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Hashing algorithms\"), mdx(\"p\", null, \"A novel feature of Storage Maps in Substrate is that they allow developers to\\nspecify the hashing algorithm that will be used to generate a map's keys. A Rust object that is used\\nto encapsulate hashing logic is referred to as a \\\"hasher\\\". Broadly speaking, the hashers that are\\navailable to Substrate developers can be described in two ways:\\n(1) whether or not they are\\ncryptographic; and\\n(2) whether or not they produce a transparent output.\"), mdx(\"p\", null, \"For the sake of\\ncompleteness, the characteristics of non-transparent hashing algorithms are described below, but\\nkeep in mind that any hasher that does not produce a transparent output has been deprecated for FRAME-based blockchains.\"), mdx(\"h3\", {\n    \"id\": \"cryptographic-hashing-algorithms\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#cryptographic-hashing-algorithms\",\n    \"aria-label\": \"cryptographic hashing algorithms permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Cryptographic hashing algorithms\"), mdx(\"p\", null, \"Cryptographic hashing algorithms are those that use cryptography to make it challenging to use the\\ninput to the hashing algorithm to influence its output. For example, a cryptographic hashing\\nalgorithm would produce a wide distribution of outputs even if the inputs were the numbers 1\\nthrough 10. It is critical to use cryptographic hashing algorithms when users are able to influence\\nthe keys of a Storage Map. Failure to do so creates an attack vector that makes it easy for\\nmalicious actors to degrade the performance of your blockchain network. An example of a map that\\nshould use a cryptographic hash algorithm to generate its keys is a map used to track account\\nbalances. In this case, it is important to use a cryptographic hashing algorithm so that an attacker\\ncannot bombard your system with many small transfers to sequential account numbers. Without a\\ncryptographic hash algorithm this would create an imbalanced storage structure that would suffer in\\nperformance.\"), mdx(Message, {\n    type: \"gray\",\n    title: \"Note\",\n    text: \"Cryptographic hashing algorithms are more complex and resource-intensive than their\\n  non-cryptographic counterparts, which is why it is important for runtime engineers to understand \\n  their appropriate usages in order to make the best use of the flexibility Substrate provides.\",\n    mdxType: \"Message\"\n  }), mdx(\"h3\", {\n    \"id\": \"transparent-hashing-algorithms\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#transparent-hashing-algorithms\",\n    \"aria-label\": \"transparent hashing algorithms permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Transparent hashing algorithms\"), mdx(\"p\", null, \"A transparent hashing algorithm is one that makes it easy to discover and verify the input that was\\nused to generate a given output. In Substrate, hashing algorithms are made transparent by\\nconcatenating the algorithm's input to its output. This makes it trivial for users to retrieve a\\nkey's original unhashed value and verify it if they'd like (by re-hashing it). The creators of\\nSubstrate have \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"deprecated the use of non-transparent hashers\"), \" within FRAME-based runtimes, so\\nthis information is provided primarily for completeness. In fact, it is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"necessary\"), \" to use a\\ntransparent hashing algorithm if you would like to access \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#iterable-storage-maps\"\n  }, \"iterable map\"), \"\\ncapabilities. Learn more about the capabilities that transparent hashing algorithms expose in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/advanced/storage#storage-map-keys\"\n  }, \"advanced storage documentation\"), \".\"), mdx(\"h3\", {\n    \"id\": \"common-substrate-hashers\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#common-substrate-hashers\",\n    \"aria-label\": \"common substrate hashers permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Common Substrate hashers\"), mdx(\"p\", null, \"This table lists some common hashers used in Substrate and denotes those that are cryptographic and\\nthose that are transparent:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Hasher\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Cryptographic\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Transparent\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"a\", {\n    parentName: \"td\",\n    \"href\": \"/rustdocs/latest/frame_support/struct.Blake2_128Concat.html\"\n  }, \"Blake2 128 Concat\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"X\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"X\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"a\", {\n    parentName: \"td\",\n    \"href\": \"/rustdocs/latest/frame_support/struct.Twox64Concat.html\"\n  }, \"TwoX 64 Concat\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"X\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"a\", {\n    parentName: \"td\",\n    \"href\": \"/rustdocs/latest/frame_support/struct.Identity.html\"\n  }, \"Identity\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"X\")))), mdx(\"p\", null, \"The Identity hasher encapsulates a hashing algorithm that has an output equal to its input (the\\nidentity function). This type of hasher should only be used when the starting key is already a\\ncryptographic hash.\"), mdx(\"h2\", {\n    \"id\": \"genesis-configuration\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#genesis-configuration\",\n    \"aria-label\": \"genesis configuration permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Genesis configuration\"), mdx(\"p\", null, \"Substrate's runtime storage APIs include capabilities to initialize storage items in the genesis\\nblock of your blockchain. The genesis storage configuration APIs expose a number of mechanisms for\\ninitializing storage, all of which have entry points in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[pallet::genesis_config]\"), \".\\nThe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GenesisConfig\"), \" data type is defined under the attribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[pallet::genesis_config]\"), \" and\\nthe attribute \", \"[\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pallet::genesis_build\"), \"]\", \" is used to build the genesis configuration.\"), mdx(\"p\", null, \"In order to consume a pallet's genesis configuration capabilities, you must include the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Config\"), \" element when adding the pallet to your runtime.\\nAll the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GenesisConfig\"), \" types for the pallets that inform a runtime will be aggregated into a single\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GenesisConfig\"), \" type for that runtime, which implements\\nthe \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sp_runtime/trait.BuildStorage.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"BuildStorage\"), \" trait\"), \". For example, in the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/node_template_runtime/struct.GenesisConfig.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"node_template_runtime::GenesisConfig\")), \" struct,\\neach attribute on this type corresponds to a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GenesisConfig\"), \" from the runtime's pallets that has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Config\"), \" element.\\nUltimately, the runtime's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GenesisConfig\"), \" is exposed by way of\\nthe \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sc_chain_spec/trait.ChainSpec.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"ChainSpec\"), \" trait\"), \".\"), mdx(\"p\", null, \"For a complete\\nand concrete example of using Substrate's genesis storage configuration capabilities, refer to\\nthe genesis configuration for the Society pallet's storage in\\nthe \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/substrate/blob/master/bin/node/cli/src/chain_spec.rs\"\n  }, \"chain specification that ships with the Substrate code base\"), \".\\nKeep reading for a more detailed descriptions of these capabilities.\"), mdx(\"h3\", {\n    \"id\": \"genesis_config\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#genesis_config\",\n    \"aria-label\": \"genesis_config permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"genesis_config\")), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/attr.pallet.html#genesis-config-palletgenesis_config-optional\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"#[pallet::genesis_config]\")), \"\\nmacro provides an extension that will add an attribute to the pallet's\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GenesisConfig\"), \" data type. The value of this attribute will be used as the initial value of the storage\\nitem in your chain's genesis block. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config\"), \" extension takes a parameter that will determine the\\nname of the attribute on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GenesisConfig\"), \" data type \", \"\\u2014\", \" this parameter is optional if the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#getter-methods\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"get\"), \" extension\"), \" is provided.\"), mdx(\"p\", null, \"Here is an example that demonstrates using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config\"), \" extension with a Storage Value named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MyVal\"), \"\\nto create an attribute named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init_val\"), \" on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GenesisConfig\"), \" data type for the Storage Value's\\npallet. This attribute is then used in an example that demonstrates using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GenesisConfig\"), \" types\\nto set the Storage Value's initial value in your chain's genesis block.\"), mdx(\"p\", null, \"In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"my_pallet/src/lib.rs\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::genesis_config]\\npub struct GenesisConfig<T: Config> {\\n        pub init_val: u64,\\n    }\\n\")), mdx(\"p\", null, \"In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chain_spec.rs\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"GenesisConfig {\\n    my_pallet: Some(MyPalletConfig {\\n        init_val: 221u64 + SOME_CONSTANT_VALUE,\\n    }),\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"genesis_build\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#genesis_build\",\n    \"aria-label\": \"genesis_build permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"genesis_build\")), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/attr.pallet.html#genesis-build-palletgenesis_build-optional\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"#[pallet::genesis_build]\")), \"\\nattribute allows you to define how \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"genesis_configuration\"), \" is built within the pallet itself (this gives you access to the pallet's private\\nfunctions). \"), mdx(\"p\", null, \"Here is an example that demonstrates using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[pallet::genesis_config]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[pallet::genesis_build]\"), \" to set the initial value of a storage item. In\\nthis case, the example involves two storage items: one that represents a list of member account IDs\\nand another that designates a special member from the list (the prime member).\"), mdx(\"p\", null, \"In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"my_pallet/src/lib.rs\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::genesis_config]\\nstruct GenesisConfig {\\n    members: Vec<T::AccountId>,\\n    prime: T::AccountId,\\n}\\n\\n#[pallet::genesis_build]\\nimpl<T: Config> GenesisBuild<T> for GenesisConfig {\\n    fn build(&self) {\\n        Pallet::<T>::initialize_members(&config.members);\\n        SomeStorageItem::<T>::put(self.prime);\\n  }\\n}\\n\")), mdx(\"p\", null, \"In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chain_spec.rs\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"GenesisConfig {\\n    my_pallet: Some(MyPalletConfig {\\n        orig_ids: LIST_OF_IDS,\\n    }),\\n}\\n\")), mdx(\"p\", null, \"You can also use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"genesis_build\"), \" to define a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GenesisConfig\"), \" attribute that\\nis not bound to a particular storage item. This may be\\ndesireable if you wish to invoke a private helper function within your pallet that sets several\\nstorage items, or invoke a function defined in some other pallets included within your pallet.\\nFor example, using an imaginary private function called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"intitialize_members\"), \", this would look like:\"), mdx(\"p\", null, \"In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"my_pallet/src/lib.rs\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[pallet::genesis_config]\\nstruct GenesisConfig {\\n    members: Vec<T::AccountId>,\\n    prime: T::AccountId,\\n}\\n\\n#[pallet::genesis_build]\\nimpl<T: Config> GenesisBuild<T> for GenesisConfig {\\n    fn build(&self) {\\n        Pallet::<T>::initialize_members(&config.members);\\n        SomeStorageItem::<T>::put(self.prime);\\n  }\\n}\\n\")), mdx(\"p\", null, \"In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chain_spec.rs\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"GenesisConfig {\\n    my_pallet: Some(MyPalletConfig {\\n        orig_ids: LIST_OF_IDS,\\n    }),\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"best-practices\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#best-practices\",\n    \"aria-label\": \"best practices permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Best practices\"), mdx(\"p\", null, \"Substrate's goal is to provide a flexible framework that allows people to build the blockchain that\\nsuits their needs \", \"\\u2014\", \" the creators of Substrate tend not to think in terms of \\\"right\\\" or \\\"wrong\\\". Nonetheless, the Substrate codebase adheres to a number of best practices in order to promote the\\ncreation of blockchain networks that are secure, performant, and maintainable in the long-term. The\\nfollowing sections outline best practices for using Substrate storage and also describe the\\nimportant first principles that motivated them.\"), mdx(\"h3\", {\n    \"id\": \"what-to-store\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#what-to-store\",\n    \"aria-label\": \"what to store permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"What to store\"), mdx(\"p\", null, \"Remember, the fundamental principle of blockchain runtime storage is to minimize its use. Only\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"consensus-critical\"), \" data should be stored in your runtime. When possible, use techniques like\\nhashing to reduce the amount of data you must store. For instance, many of Substrate's governance\\ncapabilities (e.g.\\nthe Democracy pallet's \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/pallet_democracy/pallet/enum.Call.html#variant.propose\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"propose\"), \" dispatchable\"), \")\\nallow network participants to vote on the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"hash\"), \" of a dispatchable call, which is always bounded in\\nsize, as opposed to the call itself, which may be unbounded in length. This is especially true in\\nthe case of runtime upgrades where the dispatchable call takes an entire runtime Wasm blob as its\\nparameter. Because these governance mechanisms are implemented \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"on-chain\"), \", all the information that\\nis needed to come to consensus on the state of a given proposal must also be stored on-chain - this\\nincludes \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"what\"), \" is being voted on. However, by binding an on-chain proposal to its hash, Substrate's\\ngovernance mechanisms allow this to be done in a way that defers bringing all the data associated\\nwith a proposal on-chain until \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"after\"), \" it has been approved. This means that storage is not wasted\\non proposals that fail. Once a proposal has passed, someone can initiate the actual dispatchable\\ncall (including all its parameters), which will be hashed and compared to the hash in the proposal.\\nAnother common pattern for using hashes to minimize data that is stored on-chain is to store the\\npre-image associated with an object in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.ipfs.io\"\n  }, \"IPFS\"), \"; this means that only the IPFS\\nlocation (a hash that is bounded in size) needs to be stored on-chain.\"), mdx(\"p\", null, \"Hashes are only one mechanism that can be used to control the size of runtime storage. An example of\\nanother mechanism is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#create-bounds\"\n  }, \"bounds\"), \".\"), mdx(\"h3\", {\n    \"id\": \"verify-first-write-last\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#verify-first-write-last\",\n    \"aria-label\": \"verify first write last permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Verify first, write last\"), mdx(\"p\", null, \"Substrate does not cache state prior to extrinsic dispatch. Instead, it applies changes directly as\\nthey are invoked. If an extrinsic fails, any state changes will persist. Because of this, it is\\nimportant not to make any storage mutations until it is certain that all preconditions have been\\nmet. In general, code blocks that may result in mutating storage should be structured as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"{\\n  // all checks and throwing code go here\\n\\n  // ** no throwing code below this line **\\n\\n  // all event emissions & storage writes go here\\n}\\n\")), mdx(\"p\", null, \"Do not use runtime storage to store intermediate or transient data within the context of an\\noperation that is logically atomic or data that will not be needed if the operation is to fail. This\\ndoes not mean that runtime storage should not be used to track the state of ongoing actions that\\nrequire multiple atomic operations, as in the case of\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/pallet_utility/pallet/enum.Call.html#variant.as_multi\"\n  }, \"the multi-signature capabilities from the Utility pallet\"), \".\\nIn this case, runtime storage is used to track the signatories on a dispatchable call even though a\\ngiven call may never receive enough signatures to actually be invoked. In this case, each signature\\nis considered an atomic event in the ongoing multi-signature operation; the data needed to record a\\nsingle signature is not stored until after all the preconditions associated with that signature have\\nbeen met.\"), mdx(\"h3\", {\n    \"id\": \"create-bounds\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#create-bounds\",\n    \"aria-label\": \"create bounds permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Create bounds\"), mdx(\"p\", null, \"Creating bounds on the size of storage items is an extremely effective way to control the use of\\nruntime storage and one that is used repeatedly throughout the Substrate codebase. In general, any\\nstorage item whose size is determined by user action should have a bound on it.\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/pallet_utility/trait.Config.html#associatedtype.MaxSignatories\"\n  }, \"The multi-signature capabilities from the Utility pallet\"), \"\\nthat were described above are one such example. In this case, the list of signatories associated\\nwith a multi-signature operation is provided by the multi-signature participants. Because this\\nsignatory list is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#what-to-store\"\n  }, \"necessary to come to consensus\"), \" on the state of the\\nmulti-signature operation, it must be stored in the runtime. However, in order to give runtime\\ndevelopers control over how much space in storage these lists may occupy, the Utility pallet\\nrequires users to configure a bound on this number that will be included as a\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#verify-first-write-last\"\n  }, \"precondition\"), \" before anything is written to storage.\"), mdx(\"h2\", {\n    \"id\": \"next-steps\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#next-steps\",\n    \"aria-label\": \"next steps permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Next steps\"), mdx(\"h3\", {\n    \"id\": \"learn-more\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#learn-more\",\n    \"aria-label\": \"learn more permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Learn more\"), mdx(\"p\", null, \"Read \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/advanced/storage\"\n  }, \"the advanced storage documentation\"), \".\"), mdx(\"h3\", {\n    \"id\": \"examples\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#examples\",\n    \"aria-label\": \"examples permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Examples\"), mdx(\"p\", null, \"Check out some guides covering various topics on storage:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-to-guides/v3/basics/mint-token\"\n  }, \"Using a Storage Map\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-to-guides/v3/pallet-design/storage-value\"\n  }, \"Structs in storage\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-to-guides/v3/storage-migrations/basics\"\n  }, \"Storage migration\"))), mdx(\"h3\", {\n    \"id\": \"references\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#references\",\n    \"aria-label\": \"references permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"References\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Visit the reference docs for the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/attr.pallet.html#storage-palletstorage-optional\"\n  }, \"#[frame_support::pallet] macro\"), \"\\nfor more details about the available storage declarations.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Visit the reference docs for\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/types/struct.StorageValue.html\"\n  }, \"StorageValue\"), \",\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/types/struct.StorageMap.html\"\n  }, \"StorageMap\"), \",\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/types/struct.StorageDoubleMap.html\"\n  }, \"StorageDoubleMap\"), \"\\nand \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/storage/types/struct.StorageNMap.html\"\n  }, \"StorageNMap\"), \" to learn more about their APIs.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#storage-items","title":"Storage items","items":[{"url":"#storage-value","title":"Storage value"},{"url":"#storage-map","title":"Storage map"},{"url":"#double-storage-map","title":"Double storage map"},{"url":"#n-storage-map","title":"N storage map"}]},{"url":"#declaring-storage-items","title":"Declaring storage items","items":[{"url":"#querykindtrait","title":"QueryKindTrait"},{"url":"#visibility","title":"Visibility"},{"url":"#getter-methods","title":"Getter methods"},{"url":"#default-values","title":"Default values"}]},{"url":"#accessing-storage-items","title":"Accessing storage items"},{"url":"#hashing-algorithms","title":"Hashing algorithms","items":[{"url":"#cryptographic-hashing-algorithms","title":"Cryptographic hashing algorithms"},{"url":"#transparent-hashing-algorithms","title":"Transparent hashing algorithms"},{"url":"#common-substrate-hashers","title":"Common Substrate hashers"}]},{"url":"#genesis-configuration","title":"Genesis configuration","items":[{"url":"#genesis_config","title":"genesis_config"},{"url":"#genesis_build","title":"genesis_build"}]},{"url":"#best-practices","title":"Best practices","items":[{"url":"#what-to-store","title":"What to store"},{"url":"#verify-first-write-last","title":"Verify first, write last"},{"url":"#create-bounds","title":"Create bounds"}]},{"url":"#next-steps","title":"Next steps","items":[{"url":"#learn-more","title":"Learn more"},{"url":"#examples","title":"Examples"},{"url":"#references","title":"References"}]}]},"fileAbsolutePath":"/Users/a212/Desktop/substrate-docs/v3/docs/03-runtime/e-storage/index.mdx"}},"pageContext":{"slug":"/v3/runtime/storage","version":"3.0","locale":"en","hrefLang":"en-US","originalPath":"/v3/runtime/storage/","dateFormat":"MM/DD/YYYY"}},
    "staticQueryHashes": ["1239077767","1821483254","2966362950","3280999885"]}