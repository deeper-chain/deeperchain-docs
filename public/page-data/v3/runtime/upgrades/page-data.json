{
    "componentChunkName": "component---src-templates-kb-template-tsx",
    "path": "/v3/runtime/upgrades/",
    "result": {"data":{"mdx":{"frontmatter":{"slug":"/v3/runtime/upgrades","title":"Upgrades","hideNav":null,"section":"docs","category":"runtime"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Upgrades\",\n  \"slug\": \"/v3/runtime/upgrades\",\n  \"version\": 3,\n  \"section\": \"docs\",\n  \"category\": \"runtime\",\n  \"keywords\": null\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Message = makeShortcode(\"Message\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The enablement of forkless runtime upgrades is one of the defining characteristics of the Substrate\\nframework for blockchain development. This capability is made possible by including the definition\\nof the state transition function, i.e. the runtime itself, as an element in the blockchain's\\nevolving runtime state. This allows network maintainers to leverage the blockchain's capabilities\\nfor trustless, decentralized consensus to securely make enhancements to the runtime.\"), mdx(\"p\", null, \"In the FRAME system for runtime development, the System library defines\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_system/pallet/enum.Call.html#variant.set_code\"\n  }, \"the \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"set_code\"), \" call\"), \"\\nthat is used to update the definition of the runtime. The\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/tutorials/v3/forkless-upgrades#schedule-an-upgrade\"\n  }, \"Forkless Upgrade a Chain tutorial\"), \" describes the details\\nof FRAME runtime upgrades and demonstrates two mechanisms for performing them. Both upgrades\\ndemonstrated in that tutorial are strictly \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"additive\"), \", which means that they modify the runtime by\\nmeans of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"extending\"), \" it as opposed to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"updating\"), \" the existing runtime state. In the event that a\\nruntime upgrade defines changes to existing state, it will likely be necessary to perform a \\\"storage\\nmigration\\\".\"), mdx(\"h2\", {\n    \"id\": \"runtime-versioning\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#runtime-versioning\",\n    \"aria-label\": \"runtime versioning permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Runtime versioning\"), mdx(\"p\", null, \"In order for the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/advanced/executor\"\n  }, \"executor\"), \" to be able to select the appropriate runtime\\nexecution environment, it needs to know the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec_name\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec_version\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"authoring_version\"), \" of\\nboth the native and Wasm runtime.\"), mdx(\"p\", null, \"The runtime provides a\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sp_version/struct.RuntimeVersion.html\"\n  }, \"runtime version struct\"), \".\\nA sample runtime version struct is shown below:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"pub const VERSION: RuntimeVersion = RuntimeVersion {\\n  spec_name: create_runtime_str!(\\\"node-template\\\"),\\n  impl_name: create_runtime_str!(\\\"node-template\\\"),\\n  authoring_version: 1,\\n  spec_version: 1,\\n  impl_version: 1,\\n  apis: RUNTIME_API_VERSIONS,\\n  transaction_version: 1,\\n};\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec_name\"), \": The identifier for the different Substrate runtimes.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"impl_name\"), \": The name of the implementation of the spec. This is of little consequence for the\\nnode and serves only to differentiate code of different implementation teams.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"authoring_version\"), \": The version of the authorship interface. An authoring node will not attempt\\nto author blocks unless this is equal to its native runtime.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec_version\"), \": The version of the runtime specification. A full node will not attempt to use its\\nnative runtime in substitute for the on-chain Wasm runtime unless all of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec_name\"), \",\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec_version\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"authoring_version\"), \" are the same between Wasm and native.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"impl_version\"), \": The version of the implementation of the specification. Nodes are free to ignore\\nthis; it serves only as an indication that the code is different; as long as the other two\\nversions are the same then while the actual code may be different, it is nonetheless required to\\ndo the same thing. Non-consensus-breaking optimizations are about the only changes that could be\\nmade which would result in only the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"impl_version\"), \" changing.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transaction_version\"), \": The version of the extrinsics interface. This number must be updated in the\\nfollowing circumstances: extrinsic parameters (number, order, or types) have been changed;\\nextrinsics or pallets have been removed; or the pallet order in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"construct_runtime!\"), \" macro\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"or\"), \" extrinsic order in a pallet has been changed. If this number is updated, then the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec_version\"), \" must also be updated.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"apis\"), \" is a list of supported\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sp_api/macro.impl_runtime_apis.html\"\n  }, \"runtime APIs\"), \" along\\nwith their versions.\"))), mdx(\"p\", null, \"As mentioned above, the executor always verifies that the native runtime has the same\\nconsensus-driven logic before it chooses to execute it, independent of whether the version is higher\\nor lower.\"), mdx(Message, {\n    type: \"gray\",\n    title: \"Note\",\n    text: \"The runtime versioning is manually set. Thus the executor can still make inappropriate\\n  decisions if the runtime version is misrepresented.\",\n    mdxType: \"Message\"\n  }), mdx(\"h3\", {\n    \"id\": \"accessing-the-runtime-version\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#accessing-the-runtime-version\",\n    \"aria-label\": \"accessing the runtime version permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Accessing the runtime version\"), mdx(\"p\", null, \"The runtime version is useful for application or integration developers that are building on a FRAME\\nruntime. The FRAME runtime system exposes this information by way of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state.getRuntimeVersion\"), \"\\nRPC endpoint, which accepts an optional block identifier. Most developers building on a FRAME-based\\nblockchain will use the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../metadata\"\n  }, \"runtime's metadata\"), \" to understand the APIs the runtime exposes\\nand the requirements for interacting with these APIs. The runtime's metadata should \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"only\"), \" change\\nwhen the chain's\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sp_version/struct.RuntimeVersion.html#structfield.spec_version\"\n  }, \"runtime \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"spec_version\")), \"\\nchanges.\"), mdx(\"h2\", {\n    \"id\": \"forkless-runtime-upgrades\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#forkless-runtime-upgrades\",\n    \"aria-label\": \"forkless runtime upgrades permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Forkless runtime upgrades\"), mdx(\"p\", null, \"Traditional blockchains require a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Fork_(blockchain)\"\n  }, \"hard fork\"), \"\\nwhen upgrading the state transition function of their chain. This requires node operators to stop\\ntheir nodes and manually upgrade to the latest executable. For distributed production networks,\\ncoordination of a hard fork upgrades can be a complex process.\"), mdx(\"p\", null, \"The culmination of the properties listed on this page allows for Substrate-based blockchains to\\nperform \\\"forkless runtime upgrades\\\". This means that the upgrade of the runtime logic can happen in\\nreal time without causing a fork in the network.\"), mdx(\"p\", null, \"To perform a forkless runtime upgrade, Substrate uses existing runtime logic to update the Wasm\\nruntime stored on the blockchain to a new consensus-breaking version with new logic. This upgrade\\ngets pushed out to all syncing nodes on the network as a part of the consensus process. Once the\\nWasm runtime is upgraded, the executor will see that the native runtime \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec_name\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec_version\"), \",\\nor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"authoring_version\"), \" no longer matches this new Wasm runtime. As a result, it will fall back to\\nexecute the canonical Wasm runtime instead of using the native runtime in any of the execution\\nprocesses.\"), mdx(\"h2\", {\n    \"id\": \"storage-migrations\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#storage-migrations\",\n    \"aria-label\": \"storage migrations permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Storage migrations\"), mdx(\"p\", null, \"Storage migrations are custom, one-time functions that allow developers to rework existing storage\\nin order to convert it to conform to updated expectations. For instance, imagine a runtime upgrade\\nthat changes the data type used to represent user balances from an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unsigned\"), \" integer to a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"signed\"), \"\\ninteger - in this case, the storage migration would read the existing value as an unsigned integer\\nand write back an updated value that has been converted to a signed integer. Failure to perform a\\nstorage migration when needed will result in the runtime execution engine misinterpreting the\\nstorage values that represent the runtime state and lead to undefined behavior. Substrate runtime\\nstorage migrations fall into a category of storage management broadly referred to as\\n\\\"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Data_migration\"\n  }, \"data migrations\"), \"\\\".\"), mdx(\"h3\", {\n    \"id\": \"storage-migrations-with-frame\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#storage-migrations-with-frame\",\n    \"aria-label\": \"storage migrations with frame permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Storage migrations with FRAME\"), mdx(\"p\", null, \"FRAME storage migrations are implemented by way of\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/traits/trait.OnRuntimeUpgrade.html\"\n  }, \"the \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"OnRuntimeUpgrade\"), \" trait\"), \",\\nwhich specifies a single function, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_runtime_upgrade\"), \". This function provides a hook that allows\\nruntime developers to specify logic that will run immediately \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"after\"), \" a runtime upgrade but \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"before\"), \"\\nany \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/concepts/execution#executing-a-block\"\n  }, \"extrinsics or even the \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"on_initialize\"), \" function\"), \" has executed.\"), mdx(\"h3\", {\n    \"id\": \"preparing-for-a-migration\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#preparing-for-a-migration\",\n    \"aria-label\": \"preparing for a migration permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Preparing for a migration\"), mdx(\"p\", null, \"Preparing for a storage migration means understanding the changes that are defined by a runtime\\nupgrade. The Substrate repository uses\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/substrate/pulls?q=is%3Apr+label%3AD1-runtime-migration\"\n  }, \"the \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"D1-runtime-migration\"), \" label\"), \"\\nto designate such changes.\"), mdx(\"h3\", {\n    \"id\": \"writing-a-migration\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#writing-a-migration\",\n    \"aria-label\": \"writing a migration permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Writing a migration\"), mdx(\"p\", null, \"Each runtime migration will be different, but there are certain conventions and best practices that\\nshould be followed.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Extract migrations into reusable functions and write tests for them.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Include logging in migrations to assist in debugging.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Remember that migrations are executed within the context of the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"upgraded\"), \" runtime, which means\\nthat migration code may need to include deprecated types, as in\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/hicommonwealth/substrate/blob/5f3933f5735a75d2d438341ec6842f269b886aaa/frame/indices/src/migration.rs#L5-L22\"\n  }, \"this example\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use storage versions to make migrations safer by making them more declarative, as in\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/paritytech/substrate/blob/c79b522a11bbc7b3cf2f4a9c0a6627797993cb79/frame/elections-phragmen/src/lib.rs#L119-L157\"\n  }, \"this example\"), \".\")), mdx(\"h3\", {\n    \"id\": \"ordering-migrations\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#ordering-migrations\",\n    \"aria-label\": \"ordering migrations permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Ordering migrations\"), mdx(\"p\", null, \"By default, FRAME will order the execution of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_runtime_upgrade\"), \" functions according to the order\\nin which the pallets appear in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"construct_runtime!\"), \" macro - in particular, they will run in\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"reverse\"), \" (top-to-bottom) order. FRAME exposes a capability to inject storage migrations in a custom\\norder, if needed (see an\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/hicommonwealth/edgeware-node/blob/7b66f4f0a9ec184fdebcccd41533acc728ebe9dc/node/runtime/src/lib.rs#L845-L866\"\n  }, \"example here\"), \").\"), mdx(\"p\", null, \"FRAME storage migrations will run in this order:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"frame_system::on_runtime_upgrade\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Custom \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"on_runtime_upgrade\"), \", as described above\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"All \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"on_runtime_upgrade\"), \" functions defined in the pallets included in the runtime, in the order\\ndescribed above\")), mdx(Message, {\n    type: \"gray\",\n    title: \"Note\",\n    text: \"If you are running on a Substrate version after [commit `#bd8c1cae`](https://github.com/paritytech/substrate/commit/bd8c1cae434dd6050833555e14967e3cd936e004), the storage migration order has been updated\\n  to:\\n  1. Custom `on_runtime_upgrade`\\n  2. `frame_system::on_runtime_upgrade`\\n  3. All `on_runtime_upgrade` functions defined in all included pallets.\\n  \\n  The reason is to cater for scenarios where one needs to write custom code to make\\n  `frame_system::on_runtime_upgrade` run and return successfully. Refer to the details [here](https://github.com/paritytech/substrate/issues/8683).\",\n    mdxType: \"Message\"\n  }), mdx(\"h3\", {\n    \"id\": \"testing-migrations\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#testing-migrations\",\n    \"aria-label\": \"testing migrations permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Testing migrations\"), mdx(\"p\", null, \"It is important to test storage migrations and a number of utilities exist to assist in this\\nprocess. The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/substrate-debug-kit\"\n  }, \"Substrate Debug Kit\"), \" includes a\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/substrate-debug-kit/tree/master/remote-externalities\"\n  }, \"Remote Externalities\"), \"\\ntool that allows storage migration unit testing to be safely performed on live chain data. The\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/maxsam4/fork-off-substrate\"\n  }, \"Fork Off Substrate\"), \" script makes it easy to create a\\nchain specification that can be used to bootstrap a local test chain for testing runtime upgrades\\nand storage migrations.\"), mdx(\"h2\", {\n    \"id\": \"learn-more\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#learn-more\",\n    \"aria-label\": \"learn more permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Learn more\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Parity Runtime Engineer Alexander Popiak maintains a\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/apopiak/substrate-migrations\"\n  }, \"Substrate Migrations\"), \" repository with lots of\\nhelpful information about Substrate runtime upgrades and storage migrations.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Learn how to \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-to-guides/v3/storage-migrations/basics/\"\n  }, \"write a basic storage migration for a pallet\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#runtime-versioning","title":"Runtime versioning","items":[{"url":"#accessing-the-runtime-version","title":"Accessing the runtime version"}]},{"url":"#forkless-runtime-upgrades","title":"Forkless runtime upgrades"},{"url":"#storage-migrations","title":"Storage migrations","items":[{"url":"#storage-migrations-with-frame","title":"Storage migrations with FRAME"},{"url":"#preparing-for-a-migration","title":"Preparing for a migration"},{"url":"#writing-a-migration","title":"Writing a migration"},{"url":"#ordering-migrations","title":"Ordering migrations"},{"url":"#testing-migrations","title":"Testing migrations"}]},{"url":"#learn-more","title":"Learn more"}]},"fileAbsolutePath":"/Users/a212/Desktop/substrate-docs/v3/docs/03-runtime/m-upgrades/index.mdx"}},"pageContext":{"slug":"/v3/runtime/upgrades","version":"3.0","locale":"en","hrefLang":"en-US","originalPath":"/v3/runtime/upgrades/","dateFormat":"MM/DD/YYYY"}},
    "staticQueryHashes": ["1239077767","1821483254","2966362950","3280999885"]}