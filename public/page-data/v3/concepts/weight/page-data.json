{
    "componentChunkName": "component---src-templates-kb-template-tsx",
    "path": "/v3/concepts/weight/",
    "result": {"data":{"mdx":{"frontmatter":{"slug":"/v3/concepts/weight","title":"Transaction Weight","hideNav":null,"section":"docs","category":"concepts"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Transaction Weight\",\n  \"slug\": \"/v3/concepts/weight\",\n  \"version\": 3,\n  \"section\": \"docs\",\n  \"category\": \"concepts\",\n  \"keywords\": null\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Message = makeShortcode(\"Message\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Resources available to chains are limited. These resources include memory usage, storage I/O,\\ncomputation, transaction/block size and state database size. Substrate makes several\\nmechanisms available to manage\\naccess to resources and to prevent individual components of the chain from consuming too much of any\\nresource. Weights are the mechanism used to manage the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"time it takes to validate\"), \" a block.\\nGenerally speaking, this comes from limiting the storage I/O and computation.\"), mdx(Message, {\n    type: \"gray\",\n    title: \"Note\",\n    text: \"Weights are not used to restrict access to other resources, such as storage itself or memory\\n  footprint. Other mechanisms must be used for this.\",\n    mdxType: \"Message\"\n  }), mdx(\"p\", null, \"The amount of weight a block may contain is limited, and optional weight consumption (i.e. weight\\nthat is not required to be deployed as part of the block's initialization or finalization phases nor\\nused in mandatory inherent extrinsics) will generally be limited through economic measures \", \"\\u2014\", \" or in\\nsimple terms, through transaction fees. The fee implications of the weight system are covered in the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/weights-and-fees\"\n  }, \"Transaction Fees document\"), \".\"), mdx(\"p\", null, \"Substrate defines one unit of weight as one picosecond of execution time, that is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"10\", mdx(\"sup\", null, \"12\"), \"\\nweight = 1 second\"), \", or 1,000 weight = 1 nanosecond, on fixed reference hardware (Intel Core\\ni7-7700K CPU with 64GB of RAM and an NVMe SSD).\"), mdx(\"p\", null, \"Benchmarking on reference hardware makes\\nweights comparable across runtimes, which allows composability of software components from different\\nsources. In order to tune a runtime for different validator hardware assumptions, you can set a\\ndifferent maximum block weight. For example, in order to allow validators to participate that are\\nonly half as fast as the reference machine, the maximum block weight should be half of the default,\\nkeeping the default block time.\"), mdx(\"p\", null, \"The maximum block weight should be equivalent to one-third of the target block time, allocating one\\nthird for block construction, one third for network propagation, and one third for import and\\nverification. Doubling the block time would allow a doubling of the maximum block weight. These\\ntuning options give runtime developers a way to make the optimal transaction per second vs. hardware\\nrequirement trade-offs for their use case. These trade-offs can be tuned with runtime updates to\\nkeep up with hardware and software improvements.\"), mdx(\"h2\", {\n    \"id\": \"weight-fundamentals\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#weight-fundamentals\",\n    \"aria-label\": \"weight fundamentals permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Weight fundamentals\"), mdx(\"p\", null, \"Weights represent the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"limited\"), \" time that your blockchain has to validate a block. This includes\\ncomputational cycles, and storage I/O. A custom implementation may use complex structures to express\\nthis. Substrate weights are simply a\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_support/weights/type.Weight.html\"\n  }, \"numeric value\"), \".\"), mdx(\"p\", null, \"A weight calculation should always:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Be computable \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ahead of dispatch\"), \". A block producer should be able to examine the weight of a\\ndispatchable before actually deciding to accept it or not.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Consume few resources itself. It does not make sense to consume similar resources computing a\\ntransaction's weight as would be spent to execute it. Thus, weight computation should be much\\nlighter than dispatch.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Be able to determine resources used without consulting on-chain state. Weights are good at\\nrepresenting \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"fixed\"), \" measurements or measurements based solely on the parameters of the\\ndispatchable function where no expensive I/O is necessary. Weights are not so useful when the cost\\nis dependent on the chain-state.\")), mdx(\"p\", null, \"In the case that the weight of a dispatchable is heavily dependent on chain-state case, two options\\nare available:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Determine or introduce a forced upper limit to the amount of weight a dispatchable could possibly\\ntake. If the difference between the enforced upper limit and the least possible amount of weight a\\ndispatchable could take is small, then it can just be assumed to always be at the upper limit of\\nthe weight without consulting the state. If the difference is too great, however, then the\\neconomic cost of making lesser transactions might be too great which will warp the incentives and\\ncreate inefficiencies in throughput.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Require the effective weight (or precursors that can be used to efficiently compute it) be passed\\nin as parameters to the dispatch. The weight charged should be based on these parameters but also\\ncover the amount of time it takes to verify them during dispatch. Verification must take place to\\nensure the weighing parameters correspond accurately to on-chain state and if they don't then the\\noperation should gracefully error.\")), mdx(\"h3\", {\n    \"id\": \"weight-factors\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#weight-factors\",\n    \"aria-label\": \"weight factors permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Weight factors\"), mdx(\"p\", null, \"Several factors impact execution time, and therefore weight calculation. One large contributor is\\nthe number of database accesses that are performed by a dispatchable. Because the cost of a database\\naccess is greatly dependent on the database backend and storage hardware, the weight calculations\\nare parameterized over the weight costs of database reads and writes. These costs are determined by\\nbenchmarking each available database backend on some reference hardware. This allows switching\\ndatabase backends without changing all weight calculations.\"), mdx(\"p\", null, \"In addition to only using constants for the pre-dispatch weight calculation, the developer has the\\nability to factor in the input parameters of the given dispatchable. This can be useful when the\\nexecution time depends on, for example, the length of one parameter. It is important that these\\ncalculations do not entail any meaningful work themselves. The pre-dispatch maximum weight should be\\ntrivially computable from the input arguments with some basic arithmetic.\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_system/pallet/index.html\"\n  }, \"System pallet\"), \" is\\nresponsible for accumulating the weight of each block as it gets executed and making sure that it\\ndoes not exceed the limit. The\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/pallet_transaction_payment/index.html\"\n  }, \"Transaction Payment pallet\"), \"\\nis responsible for interpreting these weights and deducting fees based upon them. The weighing\\nfunction is part of the runtime so it can be upgraded if needed.\"), mdx(\"h2\", {\n    \"id\": \"post-dispatch-weight-correction\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#post-dispatch-weight-correction\",\n    \"aria-label\": \"post dispatch weight correction permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Post dispatch weight correction\"), mdx(\"p\", null, \"There are cases where the actual weight of a dispatchable is not trivially computable from its\\ninputs. For example, the weight could depend on the logic path of the dispatchable. Without any\\nmeans of correcting the weight after dispatch, we would constantly overestimate and subsequently\\novercharge for those dispatchables as we must assume the worst case ahead of dispatch for the chain\\nto be safe.\"), mdx(\"p\", null, \"The post-dispatch weight correction allows any dispatchable to return its \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"actual weight\"), \" after it\\nwas executed. This weight must be less than or equal to the pre-dispatch worst case weight. For a\\nuser to be allowed to include an extrinsic, they still must be able to pay for the maximum weight,\\neven though the final payment will be based on the actual weight.\"), mdx(\"h2\", {\n    \"id\": \"block-weight-and-length-limit\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#block-weight-and-length-limit\",\n    \"aria-label\": \"block weight and length limit permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Block weight and length limit\"), mdx(\"p\", null, \"Aside from affecting fees, the main purpose of the weight system is to prevent a block from being\\nfilled with transactions that would take too long to execute. While processing transactions within a\\nblock, the System pallet accumulates both the total length of the block (sum of encoded transactions\\nin bytes) and the total weight of the block. If either of these numbers surpass the limits, no\\nfurther transactions are accepted in that block. These limits are defined in\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_system/limits/struct.BlockLength.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"MaximumBlockLength\")), \"\\nand\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_system/limits/struct.BlockWeights.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"MaximumBlockWeight\")), \".\"), mdx(\"p\", null, \"One important note about these limits is that a portion of them are reserved for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Operational\"), \"\\ndispatch class. This rule applies to both of the limits and the ratio can be found in\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/frame_system/limits/struct.BlockLength.html#method.max_with_normal_ratio\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"AvailableBlockRatio\")), \".\"), mdx(\"p\", null, \"For example, if the block length limit is 1 megabyte and the ratio is set to 80%, all transactions\\ncan fill the first 800 kilobytes of the block while the last 200 can only be filled by the\\noperational class.\"), mdx(\"p\", null, \"There is also a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Mandatory\"), \" dispatch class that can be used to ensure an extrinsic is always\\nincluded in a block regardless of its impact on block weight. Please refer to the article on\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/runtime/weights-and-fees\"\n  }, \"Transaction Fees\"), \" to learn more about the different dispatch classes and\\nwhen to use them.\"), mdx(\"h3\", {\n    \"id\": \"learn-more\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#learn-more\",\n    \"aria-label\": \"learn more permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Learn more\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/paritytech/substrate/blob/master/frame/example/src/lib.rs\"\n  }, \"Example\"), \"\\npallet.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/paritytech/substrate/blob/master/frame/transaction-payment/src/lib.rs\"\n  }, \"Transaction Payment pallet\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/paritytech/substrate/blob/master/frame/support/src/weights.rs\"\n  }, \"Weights\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#weight-fundamentals","title":"Weight fundamentals","items":[{"url":"#weight-factors","title":"Weight factors"}]},{"url":"#post-dispatch-weight-correction","title":"Post dispatch weight correction"},{"url":"#block-weight-and-length-limit","title":"Block weight and length limit","items":[{"url":"#learn-more","title":"Learn more"}]}]},"fileAbsolutePath":"/Users/a212/Desktop/substrate-docs/v3/docs/02-concepts/f-transaction-weight/index.mdx"}},"pageContext":{"slug":"/v3/concepts/weight","version":"3.0","locale":"en","hrefLang":"en-US","originalPath":"/v3/concepts/weight/","dateFormat":"MM/DD/YYYY"}},
    "staticQueryHashes": ["1239077767","1821483254","2966362950","3280999885"]}