{
    "componentChunkName": "component---src-templates-kb-template-tsx",
    "path": "/v3/advanced/block-import/",
    "result": {"data":{"mdx":{"frontmatter":{"slug":"/v3/advanced/block-import","title":"The Block Import Pipeline","hideNav":null,"section":"docs","category":"advanced"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The Block Import Pipeline\",\n  \"slug\": \"/v3/advanced/block-import\",\n  \"version\": 3,\n  \"section\": \"docs\",\n  \"category\": \"advanced\",\n  \"keywords\": null\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The block import pipeline is an abstract worker queue present in every Substrate node. It is not part of the\\nruntime. The import pipeline is responsible for processing pieces of incoming information, verifying\\nthem, and if they are valid, importing them into the node's state. The most fundamental piece of\\ninformation that the import pipeline processes is blocks themselves, but it is also responsible for\\nimporting consensus-related messages such as justifications and, in light clients, finality proofs.\"), mdx(\"p\", null, \"The import queue collects incoming elements from the network and stores them in a pool. The elements\\nare later checked for validity and discarded if they are not valid. Elements that are valid are then\\nimported into the node's local state.\"), mdx(\"p\", null, \"The import queue is codified abstractly in Substrate by means of the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sp_consensus/import_queue/trait.ImportQueue.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"ImportQueue\"), \" trait\"), \".\\nThe use of a trait allows each consensus engine to provide its own specialized implementation of the\\nimport queue, which may take advantage of optimization opportunities such as verifying multiple\\nblocks in parallel as they come in across the network.\"), mdx(\"p\", null, \"The import queue also provides some hooks via the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sp_consensus/import_queue/trait.Link.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Link\"), \" trait\"), \" that can be used\\nto follow its progress.\"), mdx(\"h2\", {\n    \"id\": \"basic-queue\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#basic-queue\",\n    \"aria-label\": \"basic queue permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Basic queue\"), mdx(\"p\", null, \"Substrate provides a default in-memory implementation of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ImportQueue\"), \" known as the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sp_consensus/import_queue/struct.BasicQueue.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"BasicQueue\")), \". The\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BasicQueue\"), \" does not do any kind of optimization, rather it performs the verification and import\\nsteps sequentially. It does, however, abstract the notion of verification through the use of the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sp_consensus/import_queue/trait.Verifier.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Verifier\")), \" trait.\"), mdx(\"p\", null, \"Any consensus engine that relies on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BasicQueue\"), \" must implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Verifier\"), \" trait. The\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Verifier\"), \" is typically responsible for tasks such as checking\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/v3/concepts/extrinsics#inherents\"\n  }, \"inherent data\"), \", and ensuring that\\nthe block is signed by the appropriate authority.\"), mdx(\"h2\", {\n    \"id\": \"block-import-trait\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#block-import-trait\",\n    \"aria-label\": \"block import trait permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Block import trait\"), mdx(\"p\", null, \"When the import queue is ready to import a block, it passes the block in question to a method\\nprovided by the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sp_consensus/block_import/trait.BlockImport.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"BlockImport\"), \" trait\"), \".\\nThis \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BlockImport\"), \" trait provides the behavior of importing a block into the node's local state\\ndatabase.\"), mdx(\"p\", null, \"One implementor of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BlockImport\"), \" trait that is used in every Substrate node is the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sc_service/client/index.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Client\")), \", which contains the node's entire\\nblock database. When a block is imported into the client, it is added to the main database of blocks\\nthat the node knows about.\"), mdx(\"h2\", {\n    \"id\": \"block-import-pipeline\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#block-import-pipeline\",\n    \"aria-label\": \"block import pipeline permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Block import pipeline\"), mdx(\"p\", null, \"In the simplest cases, blocks are imported directly into the client. But most consensus engines will\\nneed to perform additional verification on incoming blocks, update their own local auxiliary\\ndatabases, or both. To allow consensus engines this opportunity, it is common to wrap the client in\\nanother struct that also implements \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BlockImport\"), \". This nesting leads to the term \\\"block import\\npipeline\\\".\"), mdx(\"p\", null, \"An example of this wrapping is the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sc_consensus_pow/struct.PowBlockImport.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"PowBlockImport\")), \", which\\nholds a reference to another type that also implements \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BlockImport\"), \". This allows the PoW consensus\\nengine to do its own import-related bookkeeping and then pass the block to the nested \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BlockImport\"), \",\\nprobably the client. This pattern is also demonstrated in\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sc_consensus_aura/struct.AuraBlockImport.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"AuraBlockImport\")), \",\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sc_consensus_babe/struct.BabeBlockImport.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"BabeBlockImport\")), \", and\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rustdocs/latest/sc_finality_grandpa/struct.GrandpaBlockImport.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"GrandpaBlockImport\")), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BlockImport\"), \" nesting need not be limited to one level. In fact, it is common for nodes that use\\nboth an authoring engine and a finality gadget to layer the nesting even more deeply. For example,\\nPolkadot's block import pipeline consists of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BabeBlockImport\"), \", which wraps a\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GrandpaBlockImport\"), \", which wraps the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Client\"), \".\"), mdx(\"h2\", {\n    \"id\": \"learn-more\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#learn-more\",\n    \"aria-label\": \"learn more permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"className\": \"fill-current text-substrateDark dark:text-white\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Learn more\"), mdx(\"p\", null, \"Have a look at these guides that cover the block import pipeline:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-to-guides/v3/consensus/pow\"\n  }, \"Basic PoW\"), \" - the import pipeline includes\\nPoW and the client\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/how-to-guides/v3/consensus/hybrid-pos-pow\"\n  }, \"Hybrid Consensus\"), \" - the import\\npipeline is PoW, then Grandpa, then the client\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#basic-queue","title":"Basic queue"},{"url":"#block-import-trait","title":"Block import trait"},{"url":"#block-import-pipeline","title":"Block import pipeline"},{"url":"#learn-more","title":"Learn more"}]},"fileAbsolutePath":"/Users/a212/Desktop/substrate-docs/v3/docs/07-advanced/d-block-import/index.mdx"}},"pageContext":{"slug":"/v3/advanced/block-import","version":"3.0","locale":"en","hrefLang":"en-US","originalPath":"/v3/advanced/block-import/","dateFormat":"MM/DD/YYYY"}},
    "staticQueryHashes": ["1239077767","1821483254","2966362950","3280999885"]}